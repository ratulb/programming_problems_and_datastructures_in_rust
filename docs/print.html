<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming problems in rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Programming problems in rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="binary_search_tree/introduction.html"><strong aria-hidden="true">2.</strong> Binary search tree</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="binary_search_tree/tree_and_node.html"><strong aria-hidden="true">2.1.</strong> Tree and Node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="binary_search_tree/basic_apis.html"><strong aria-hidden="true">2.1.1.</strong> Basic APIs</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_insert.html"><strong aria-hidden="true">2.1.2.</strong> Tree population</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_find.html"><strong aria-hidden="true">2.1.3.</strong> Tree find</a></li><li class="chapter-item expanded "><a href="binary_search_tree/node_delete.html"><strong aria-hidden="true">2.1.4.</strong> Node delete (Two children)</a></li><li class="chapter-item expanded "><a href="binary_search_tree/delete_child.html"><strong aria-hidden="true">2.1.5.</strong> Node delete (One or no child)</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_delete.html"><strong aria-hidden="true">2.1.6.</strong> Tree delete</a></li></ol></li><li class="chapter-item expanded "><a href="binary_search_tree/additional.html"><strong aria-hidden="true">2.2.</strong> Additional APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="binary_search_tree/tree_minimum.html"><strong aria-hidden="true">2.2.1.</strong> Tree minimum</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_exists.html"><strong aria-hidden="true">2.2.2.</strong> Tree exists</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_identical.html"><strong aria-hidden="true">2.2.3.</strong> Tree identical</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_contains.html"><strong aria-hidden="true">2.2.4.</strong> Tree contains</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_iterator.html"><strong aria-hidden="true">2.2.5.</strong> Tree iterator</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_into_iterator.html"><strong aria-hidden="true">2.2.6.</strong> Tree into iterator</a></li><li class="chapter-item expanded "><a href="binary_search_tree/tree_height.html"><strong aria-hidden="true">2.2.7.</strong> Tree height</a></li><li class="chapter-item expanded "><a href="binary_search_tree/lca.html"><strong aria-hidden="true">2.2.8.</strong> LCA</a></li><li class="chapter-item expanded "><a href="binary_search_tree/nth_smallest.html"><strong aria-hidden="true">2.2.9.</strong> Nth smallest</a></li><li class="chapter-item expanded "><a href="binary_search_tree/kth_smallest.html"><strong aria-hidden="true">2.2.10.</strong> Kth smallest</a></li><li class="chapter-item expanded "><a href="binary_search_tree/from_sorted_array.html"><strong aria-hidden="true">2.2.11.</strong> From sorted array</a></li><li class="chapter-item expanded "><a href="binary_search_tree/validation.html"><strong aria-hidden="true">2.2.12.</strong> Tree validation</a></li><li class="chapter-item expanded "><a href="binary_search_tree/updation.html"><strong aria-hidden="true">2.2.13.</strong> Tree update</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="doubly_linkedlist/introduction.html"><strong aria-hidden="true">3.</strong> Dubley linkedlist</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="doubly_linkedlist/node_and_list.html"><strong aria-hidden="true">3.1.</strong> Node and List</a></li><li class="chapter-item expanded "><a href="doubly_linkedlist/push_front_and_back.html"><strong aria-hidden="true">3.2.</strong> Push front and push back</a></li><li class="chapter-item expanded "><a href="doubly_linkedlist/pop_front_and_back.html"><strong aria-hidden="true">3.3.</strong> Pop front and pop back</a></li><li class="chapter-item expanded "><a href="doubly_linkedlist/delete.html"><strong aria-hidden="true">3.4.</strong> List delete</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="doubly_linkedlist/delete_helpers.html"><strong aria-hidden="true">3.4.1.</strong> Delete helpers</a></li></ol></li><li class="chapter-item expanded "><a href="doubly_linkedlist/iterators.html"><strong aria-hidden="true">3.5.</strong> List iterators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="doubly_linkedlist/mutable_iterator.html"><strong aria-hidden="true">3.5.1.</strong> Mutable iterator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="doubly_linkedlist/mutable_back_iterator.html"><strong aria-hidden="true">3.5.1.1.</strong> Iterating back</a></li></ol></li><li class="chapter-item expanded "><a href="doubly_linkedlist/immutable_iterator.html"><strong aria-hidden="true">3.5.2.</strong> Bidirectional iterator</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="sorting/introduction.html"><strong aria-hidden="true">4.</strong> Sorting algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sorting/bubblesort.html"><strong aria-hidden="true">4.1.</strong> Bubble sort</a></li><li class="chapter-item expanded "><a href="sorting/insertionsort.html"><strong aria-hidden="true">4.2.</strong> Insertion sort</a></li><li class="chapter-item expanded "><a href="sorting/selectionsort.html"><strong aria-hidden="true">4.3.</strong> Selection sort</a></li><li class="chapter-item expanded "><a href="sorting/mergesort.html"><strong aria-hidden="true">4.4.</strong> Merge sort</a></li><li class="chapter-item expanded "><a href="sorting/quicksort.html"><strong aria-hidden="true">4.5.</strong> Quick sort</a></li></ol></li><li class="chapter-item expanded "><a href="lru_cache/introduction.html"><strong aria-hidden="true">5.</strong> LRU cache</a></li><li class="chapter-item expanded "><a href="heap/introduction.html"><strong aria-hidden="true">6.</strong> Heap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="heap/max_heap.html"><strong aria-hidden="true">6.1.</strong> Max heap</a></li><li class="chapter-item expanded "><a href="heap/min_heap.html"><strong aria-hidden="true">6.2.</strong> Min heap</a></li><li class="chapter-item expanded "><a href="heap/max_min_heap.html"><strong aria-hidden="true">6.3.</strong> Max min heap</a></li></ol></li><li class="chapter-item expanded "><a href="trie/introduction.html"><strong aria-hidden="true">7.</strong> Trie</a></li><li class="chapter-item expanded "><a href="prefix_suffix/introduction.html"><strong aria-hidden="true">8.</strong> Longest common prefix/suffixes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prefix_suffix/longest_prefix.html"><strong aria-hidden="true">8.1.</strong> Longest common prefix</a></li><li class="chapter-item expanded "><a href="prefix_suffix/longest_suffix.html"><strong aria-hidden="true">8.2.</strong> Longest common suffix</a></li></ol></li><li class="chapter-item expanded "><a href="permutations/introduction.html"><strong aria-hidden="true">9.</strong> String permutation</a></li><li class="chapter-item expanded "><a href="merge_ksorted_arrays/introduction.html"><strong aria-hidden="true">10.</strong> Merge k sorted arrays</a></li><li class="chapter-item expanded "><a href="substring_concatenarion/introduction.html"><strong aria-hidden="true">11.</strong> Concatenated substring indices</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming problems in rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programming-problems-in-rust"><a class="header" href="#programming-problems-in-rust">Programming problems in rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-rust-binary-search-with-parent-pointers"><a class="header" href="#a-rust-binary-search-with-parent-pointers">A rust binary search with parent pointers</a></h1>
<h2 id="why-binary-search-tree"><a class="header" href="#why-binary-search-tree">Why binary search tree?</a></h2>
<p>Binary search trees are useful - very useful. They offer fast insertion and deletion time and
unlike linked list provide fast lookup time. Arrangement of entries are ordered. By convention -
for a given entry, smaller entries are always on its left and biggers are always on the right.</p>
<h2 id="binary-search-tree-implementation-in-rust"><a class="header" href="#binary-search-tree-implementation-in-rust">Binary search tree implementation in rust</a></h2>
<p>Binary search trees (henceforth called BSTs) can be implemented in rust without parent pointers.
But deletion of an entry becomes somewhat clunky without parent pointers.</p>
<p>Here we implement a BST in rust with parent pointers. Both left and right child point to their 
parent. We make use of <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">shared references</a> -
since same parent is shared by both children as well as we need to access it from multiple contexts.
Reference counted pointer alone - <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> - is not very
useful in itself - atleast in this context - since we 'Rc' provides mutable reference to its inner
content - only if there is no other existing reference to it already. This, obviously, is not 
the case here - because children will be pointing to it all the time. We need to be able to
mutate (for example -change its value or delete) it - while there are outstanding child references
to a it. We need <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">shared interior mutability</a>. This is where <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> comes handy - it provides interior mutability when no existing 'borrow' (mutable and immutable) is in the
context and multiple shared references when there exists no mutable borrow.</p>
<p>One last thing though. If parent contains(optionally) a child and child points back at its parent,
while deleting a parent - its reference count will still be 1(or 2). Since parent's reference count is not 0 - it would not be dropped - it would be lingering in memory leading to a <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">leaky situation</a>. This is certainly undesirable and we
don't want this. Which is why we want our parent pointers to be <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html">weak</a> ones so that we can drop parents even when there are outstanding weak references to it.</p>
<p>With these understanding so far - next we define our Tree and Node. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-and-node-definition"><a class="header" href="#tree-and-node-definition">Tree and Node definition</a></h1>
<h3 id="we-define-our-tree-as-follows"><a class="header" href="#we-define-our-tree-as-follows">We define our Tree as follows:</a></h3>
<pre><code class="language-rust  ignore">#[derive(Debug, Default)]
pub struct Tree&lt;T: Ord + Default + Clone + std::fmt::Debug&gt;(Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;);

</code></pre>
<p>Our Tree is tuple struct which may or may not contain a Node. The Node itself is wrapped inside a
RefCell for interior mutability. The RefCell, in turn is wrapped inside a Rc for shared access.</p>
<p>Our tree's keys (aka entries) are generic T. T must be of type <code>Ord</code> because that is how we decide
which side of the tree an entry lands in.</p>
<p>The generic type <code>T</code> is also implements <code>Default</code>. This we are utilising for flushing out key values while deleting a Node from the tree. This becomes necessary because rust is grumpy about holes in
memory.</p>
<p>Clone was not strictly necessary - but we need it later - when we implement <code>Iterator</code> for the
tree.</p>
<p>Debug is, of course, for printing the tree. Next, we define our <code>Node</code>.</p>
<h3 id="we-define-our-node-as-follows"><a class="header" href="#we-define-our-node-as-follows">We define our Node as follows:</a></h3>
<pre><code class="language-rust  ignore">struct Node&lt;T: Ord + Default + Clone + std::fmt::Debug&gt; {
    key: T,
    left: Option&lt;Rc&lt;RefCell&lt;Tree&lt;T&gt;&gt;&gt;&gt;,
    right: Option&lt;Rc&lt;RefCell&lt;Tree&lt;T&gt;&gt;&gt;&gt;,
    parent: Option&lt;Weak&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
}

</code></pre>
<p>Node defintion is easy to understand. We have <code>key</code> of type T. Keys are what we insert into the tree.
We have left and right children - which are optional Trees contained with <code>RefCell</code> and <code>Rc</code>. We are
treating each child as a <code>Tree</code> in its own right.</p>
<p>Our parent is an optional <code>Weak</code> reference contained within a <code>RefCell</code>.</p>
<blockquote>
<p><strong>Note</strong>: All nodes will have a weak referene to a parent node except for root which would have no
parent</p>
</blockquote>
<p>Next we will look at some basic API's for <code>Tree</code> and <code>Node</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-apis"><a class="header" href="#basic-apis">Basic APIs</a></h1>
<h3 id="following-are-some-of-the-basic-apis-in-the-node-construct-to-start-with"><a class="header" href="#following-are-some-of-the-basic-apis-in-the-node-construct-to-start-with">Following are some of the basic APIs in the <code>Node</code> construct to start with:</a></h3>
<pre><code class="language-rust  ignore">    fn new(value: T) -&gt; Self {
        Self {
            key: value,
            left: None,
            right: None,
            parent: None,
        }
    }
</code></pre>
<p>The API above is internal and used to new up a bare bone <code>Node</code> struct with a value of type T.</p>
<pre><code class="language-rust  ignore">   fn wrapped_node(value: T) -&gt; Option&lt;Rc&lt;RefCell&lt;Self&gt;&gt;&gt; {
        Some(Rc::new(RefCell::new(Node::new(value))))
   }
</code></pre>
<p>We need our <code>Node</code> to be wrapped in <code>RefCell</code> and <code>Rc</code>. Above is a helper that avoids code
repetition.</p>
<h3 id="following-are-some-of-additional-helper-apis-that-are-used-internally"><a class="header" href="#following-are-some-of-additional-helper-apis-that-are-used-internally">Following are some of additional helper APIs that are used internally:</a></h3>
<pre><code class="language-rust  ignore">    //Get a reference to `Node` key
    fn key(&amp;self) -&gt; &amp;T {
        &amp;self.key
    }
    //Does this node has a left child tree
    fn has_left(&amp;self) -&gt; bool {
        self.left.is_some()
    }

    //Does this Tree rooted at this has a right child tree
    fn has_right(&amp;self) -&gt; bool {
        self.right.is_some()
    }
    //Get a shared handle to the root of left child tree
    fn left_node(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        self.left
            .as_ref()
            .and_then(|tree| tree.borrow().0.as_ref().map(Rc::clone))
    }

    //Is the given key has the same value as the left tree root node
    //Used when deleting nodes from the tree
    fn is_left_child(&amp;self, key: &amp;T) -&gt; bool {
        Self::left_node(self)
            .as_ref()
            .map(|node| node.borrow().key() == key)
            .unwrap_or(false)
    }

    //Get a shared handle to the right tree's root node
    fn right_node(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        self.right
            .as_ref()
            .and_then(|tree| tree.borrow().0.as_ref().map(Rc::clone))
    }

    //Node's parent is a weak reference that we initialize when the node
    //is inserted to the tree - we need to upgrade it to a strong reference
    //to get to the underlying parent node
    fn upgrade_parent(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        self.parent.as_ref().and_then(|weak| weak.upgrade())
    }

    //Replace this node's key with the value might be there inside the input
    //Used during delete. If this node is being deleted, then this node's key
    //is flushed out with minimum node's value that is on the right side of
    //this node
    fn replace_key(&amp;mut self, key: Option&lt;T&gt;) -&gt; Option&lt;T&gt; {
        key.map(|k| std::mem::replace(&amp;mut self.key, k))
    }

    //To avoid already borrowed error - if Rc&lt;RefCell&gt; pointing to same location
    fn right_parent&lt;'a&gt;(
        this: Option&lt;&amp;'a Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
        that: Option&lt;&amp;'a Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
    ) -&gt; Option&lt;&amp;'a Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        match (this, that) {
            (None, None) =&gt; None,
            (Some(_), None) =&gt; this,
            (None, Some(_)) =&gt; that,
            (Some(this_one), Some(that_one)) =&gt; match Rc::ptr_eq(this_one, that_one) {
                true =&gt; this,
                false =&gt; that,
            },
        }
    }
    //Clone this parent which is a weak reference
    //Used during deletion of a node. When the minimum node is taken
    //out from the right side of the node being deleted, the minimum node's
    //right tree(if any) - has to be hoisted up to point to the minimum
    //node's parent
    fn parent(&amp;self) -&gt; Option&lt;Weak&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        self.parent.as_ref().map(Weak::clone)
    }

</code></pre>
<h3 id="following-sre-some-helper-apis-for-the-tree-struct"><a class="header" href="#following-sre-some-helper-apis-for-the-tree-struct">Following sre some helper API's for the <code>Tree</code> struct:</a></h3>
<pre><code class="language-rust  ignore">   //Initialize a new tree with the value
    pub fn new(value: T) -&gt; Self {
        Tree(Some(Rc::new(RefCell::new(Node::new(value)))))
    }
    
   //Get a shared handle to the root of the tree
    fn root(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        self.0.as_ref().map(Rc::clone)
    }

   //Create new tree rooted at the input node
    fn new_branch(node: Node&lt;T&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;Tree&lt;T&gt;&gt;&gt;&gt; {
        Some(Rc::new(RefCell::new(Tree(Some(Rc::new(RefCell::new(
            node,
        )))))))
    }

   //Find the min - given a node. Result could be given node itself
   //if no more left branch is there
    fn min(node: &amp;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        match node.borrow().left_node() {
            Some(ref left_node) =&gt; Self::min(left_node),
            None =&gt; Some(Rc::clone(node)),
        }
    }
</code></pre>
<p>Now that helper APIs are out of the way - next we will look at how to populate the tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-population"><a class="header" href="#tree-population">Tree population</a></h1>
<p>The <code>insert</code> function in the <code>Tree</code> struct is responsible for populating the tree. It's straight-
forward - it looks at the current tree's root - if it does not exist - creates a new <code>Node</code> with
the given input key - sets it as the root node of the tree.</p>
<p>If the current tree's root exists, the input key is compared to the root's key and the decision
is made to as to whether to go the left or right of the tree. This is done recursively. Once the
right spot is found - a new <code>Tree</code> branch is created with the input key, its parent is set and the
newly created tree is added as left or right child of the parent.</p>
<blockquote>
<p><strong>Note</strong>: We downgrade parent's reference because children always maintain a weak pointer to its
parent. Also, we don't allow duplicate entry. </p>
</blockquote>
<h3 id="following-is-insert-function-in-its-entirety"><a class="header" href="#following-is-insert-function-in-its-entirety">Following is <code>insert</code> function in its entirety:</a></h3>
<pre><code class="language-rust  ignore">    //Populate tree with a new key
    //Duplicate keys are not added
    //Recursively calls itself to find place to add the supplied key
    pub fn insert(&amp;mut self, value: T) {
        match self.0 {
            Some(ref mut curr_tree_root) =&gt; {
                let mut node = curr_tree_root.borrow_mut();
                if node.key &gt; value {
                    match node.left {
                        Some(ref mut tree) =&gt; Self::insert(&amp;mut tree.borrow_mut(), value),
 			None =&gt; {
                            let parent = Some(Rc::downgrade(&amp;Rc::clone(curr_tree_root)));
                            let mut left = Node::new(value);
                            left.parent = parent;
                            node.left = Tree::new_branch(left);
                        }
                    }
                } else if node.key &lt; value {
                    match node.right {
                        Some(ref mut tree) =&gt; Self::insert(&amp;mut tree.borrow_mut(), value),
                        None =&gt; {
                            let parent = Some(Rc::downgrade(&amp;Rc::clone(curr_tree_root)));
                            let mut right = Node::new(value);
                            right.parent = parent;
                            node.right = Tree::new_branch(right);
                        }
                    }
                }
            }
            None =&gt; self.0 = Node::wrapped_node(value),
      }
    }
</code></pre>
<blockquote>
<p><strong>Note</strong>: We are using <code>Node::new(value)</code>, <code>Tree::new_branch(right)</code> and <code>Node::wrapped_node(value)</code> from the previous Basic APIs section here.</p>
</blockquote>
<p>Next we present the <code>Tree::find</code> function which is utilized to find a target <code>Node</code> that has to be
deleted.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-find"><a class="header" href="#tree-find">Tree find</a></h1>
<p>The tree <code>find</code> function is used to find a <code>Node (Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;)</code> corresponding to a
given key reference. It recursively visit tree's left or right branches - till it finds the node or
returns <code>None</code> otherwise.</p>
<h3 id="following-is-the-find-function-defintion"><a class="header" href="#following-is-the-find-function-defintion">Following is the <code>find</code> function defintion:</a></h3>
<pre><code class="language-rust  ignore">
    //Find the node containing the supplied key reference
    fn find(&amp;self, key: &amp;T) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        match self.0 {
            Some(ref node) if node.borrow().key() == key =&gt; Some(Rc::clone(node)),
            Some(ref node) if node.borrow().key() &gt; key =&gt; match node.borrow().left {
                Some(ref left) =&gt; Self::find(&amp;left.borrow(), key),
                None =&gt; None,
            },
            Some(ref node) if node.borrow().key() &lt; key =&gt; match node.borrow().right {
                Some(ref right) =&gt; Self::find(&amp;right.borrow(), key),
                None =&gt; None,
            },
            Some(_) =&gt; None, //Make the compiler happy
            None =&gt; None,
        }
    }
</code></pre>
<p>Now with <code>find</code> function in place, next we will look at tree's <code>delete</code> function. But before that
we will look at <code>Node::delete</code> function because tree's <code>delete</code> is heavily dependent on <code>Node::delete</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-delete-node-has-two-children"><a class="header" href="#node-delete-node-has-two-children">Node delete (Node has two children)</a></h1>
<p><code>Node::delete</code> function is invoked when target node being deleted has both right and left chidren.
We find the minimum node on the right of target. Once we find the minimum, then we find its parent
and convert parent weak reference to a strong reference.</p>
<p>Next we find the right child of min if any - this right child should be now hoisted to point to min'sparent since min is being evicted to replace deleted node's content with min's content.</p>
<p>Finally. we return the target node's content from this function.</p>
<h3 id="following-is-the-whole-nodedelete-function-with-inline-comments"><a class="header" href="#following-is-the-whole-nodedelete-function-with-inline-comments">Following is the whole <code>Node::delete</code> function with inline comments:</a></h3>
<pre><code class="language-rust  ignore">//Delete an node when it has two children
    fn delete(mut target: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;) -&gt; Option&lt;T&gt; {
        let min = target
            .as_ref()
            .and_then(|target| target.borrow().right_node().as_ref().and_then(Tree::min));
        let min_parent = min.as_ref().and_then(|min| min.borrow().upgrade_parent());
        let right_parent = Node::right_parent(target.as_ref(), min_parent.as_ref());
        let left_or_right = right_parent.as_ref().and_then(|parent| {
            min.as_ref()
                .map(|min| parent.borrow().is_left_child(min.borrow().key()))
        });
        let min = match right_parent {
            None =&gt; None,
            Some(parent) =&gt; match left_or_right {
                None =&gt; None,
                Some(true) =&gt; parent.borrow_mut().left.take(),
                Some(false) =&gt; parent.borrow_mut().right.take(),
            },
        };
        let mut min = min.map(|tree| tree.take()).and_then(|tree| tree.root());
        let min_right = min
            .as_ref()
            .and_then(|min| min.borrow_mut().right.take())
            .and_then(|tree| tree.borrow().root());
        if let Some(ref min_right) = min_right {
            min_right.borrow_mut().parent = right_parent
                .as_ref()
                .map(|parent| Rc::downgrade(&amp;Rc::clone(parent)));
        }
        if let Some(parent) = right_parent {
            match left_or_right {
                None =&gt; {}
                Some(true) =&gt; {
                    parent.borrow_mut().left = Tree::with_node(min_right.as_ref().cloned())
                }
                Some(false) =&gt; {
                    parent.borrow_mut().right = Tree::with_node(min_right.as_ref().cloned())
                }
            }
        }
        match target {
            Some(ref mut target) =&gt; target
                .borrow_mut()
                .replace_key(min.take().map(|min| min.take().key)),
            None =&gt; None,
        }
    }
}
</code></pre>
<p>The above function takes care of deleting a target node when it has both children. We have separated
out the code to handle the case when the deleted node has only one or no child but has got a parent. Let's take a look at that in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-delete-one-or-no-child"><a class="header" href="#node-delete-one-or-no-child">Node delete (One or no child)</a></h1>
<p>Node <code>delete_child</code> function gets invoked when the target node being deleted has only left or right
child or no child but has got a parent. We evict the target node and take out its key, parent and
its left or right child in a tuple.</p>
<p>Next we set the deleted node's left or right child's parent to deleted node's parent and finally 
return the deleted node's key.</p>
<h3 id="following-is-the-snippet-for-delete_child-function"><a class="header" href="#following-is-the-snippet-for-delete_child-function">Following is the snippet for <code>delete_child</code> function:</a></h3>
<pre><code class="language-rust  ignore">
    //Delete a node with single child or no child but node being deleted has parent
    //left: bool -&gt; Should we delete left or right child?
    fn delete_child(&amp;mut self, left: bool) -&gt; Option&lt;T&gt; {
        //First take out the left or right child based on the flag passed in
        let deleted = match left {
            true =&gt; self.left.take(),
            false =&gt; self.right.take(),
        };
        //result is tuple of the form as shown below
        //result = (deleted.key, deleted.parent, left or right child of deleted)
        let result = match deleted
            .and_then(|tree| tree.take().0)
            .map(|node| node.take())
            .map(|node| (node.key, node.parent, node.left.or(node.right)))
        {
            //Set deleted node's left or right child's parent to the parent of deleted
            Some((key, parent, mut tree)) =&gt; {
                if let Some(ref mut inner) = tree {
                    if let Some(ref mut tree_node) = inner.borrow_mut().0 {
                        tree_node.borrow_mut().parent = parent;
                    }
                }
                //(deleted.key, left or right of deleted
                (Some(key), tree)
            }
            None =&gt; (None, None),
        };
        //Set self left right to deleted left or right
        match left {
            true =&gt; self.left = result.1,
            false =&gt; self.right = result.1,
        }
        //deleted key
        result.0
    }

</code></pre>
<p>Now that we have discussed <code>Node</code>'s delete APIs - we can go back to <code>Tree</code>'s delete API. Lets do thatnext.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-delete"><a class="header" href="#tree-delete">Tree delete</a></h1>
<p>While deleting a node from the tree - we first find the target node that is getting deleted. If it
can not be found - we have no further business -  we return <code>None</code>.</p>
<p>If we find a target node to delete - we need to consinder few scenarios:</p>
<ul>
<li>Is it the root node that we are deleting? Then target will have no parent.
<ul>
<li>It has no child - take node out - leaving the tree empty.</li>
<li>It has left child - hoist left child up - take out its parent reference.</li>
<li>It has right child - hoist right child up - take out its parent reference.</li>
<li>It has both children - delegate to <code>Node::delete</code></li>
</ul>
</li>
<li>It is not the root node. Then the target has got a parent.
<ul>
<li>It has no child or has left or right child - delegte to <code>node.delete_child</code></li>
<li>It has both children - delegate to <code>Node::delete</code></li>
</ul>
</li>
</ul>
<h3 id="below-is-the-tree-delete-function-in-entirety"><a class="header" href="#below-is-the-tree-delete-function-in-entirety">Below is the tree delete function in entirety:</a></h3>
<pre><code class="language-rust  ignore">//Delete a node with key that equals the supplied key
    //Returns the deleted key as Some(key) or None otherwise
    pub fn delete(&amp;mut self, key: &amp;T) -&gt; Option&lt;T&gt; {
        let target = Self::find(self, key);
        match target {
            None =&gt; None,
            Some(ref node) =&gt; {
                let has_left = node.borrow().has_left();
                let has_right = node.borrow().has_right();

                let has_both = has_left &amp;&amp; has_right;
                let no_child = !has_left &amp;&amp; !has_right;
                let has_parent = node.borrow().parent.is_some();
                match has_parent {
                    false =&gt; {
                        //Delete root - root has no parent ref - hence differential treatment
                        match (no_child, has_left, has_right, has_both) {
                            (true, false, false, false) =&gt; {
                                self.0.take().map(|root| root.take().key)
                            }
                            //Has left child - remove left child's parent ref and set it as
                            //tree root
                            (false, true, false, false) =&gt; {
                                let root = self.root().take();
                                self.0 = root.as_ref().and_then(|root| {
                                    root.borrow().left_node().map(|node| {
                                        node.borrow_mut().parent.take();
                                        node
                                    })
                                });
                                //Return root's key
                                root.map(|root| root.take().key)
                            }
                            //Has right child - remove right child's parent ref and set it as
                            //tree root
                            (false, false, true, false) =&gt; {
                                let root = self.root().take();
                                self.0 = root.as_ref().and_then(|root| {
                                    root.borrow().right_node().map(|node| {
                                        node.borrow_mut().parent.take();
                                        node
                                    })
                                });
                                //Return root's key
                                root.map(|root| root.take().key)
                            }
                            //Has got both children - delete to Node::delete
                            (false, true, true, true) =&gt; Node::delete(target),
                            (_, _, _, _) =&gt; None,
                        }
                    }
                    //target node being deleted has got a parent
                    true =&gt; match (no_child, has_left, has_right, has_both) {
                        (true, false, false, false)
                        | (false, true, false, false)
                        | (false, false, true, false) =&gt; {
                                let root = self.root().take();
                                self.0 = root.as_ref().and_then(|root| {
                                    root.borrow().right_node().map(|node| {
                                        node.borrow_mut().parent.take();
                                        node
                                    })
                                });
                                //Return root's key
                                root.map(|root| root.take().key)
                            }
                            //Has got both children - delete to Node::delete
                            (false, true, true, true) =&gt; Node::delete(target),
                            (_, _, _, _) =&gt; None,
                        }
                    }
                    //target node being deleted has got a parent
                    true =&gt; match (no_child, has_left, has_right, has_both) {
                        (true, false, false, false)
                        | (false, true, false, false)
                        | (false, false, true, false) =&gt; {
                            let parent = node.borrow().upgrade_parent();
                            //Is it left or right? If no child then left is false
                            let left = parent
                                .as_ref()
                                .map_or(false, |parent| parent.borrow().is_left_child(key));
                            //Delefate to node.delete_child with boolean flag left
                            parent.and_then(|parent| parent.borrow_mut().delete_child(left))
                        }
                        //Has parent, has two children
                        //Delegate to Node::delete
                        (false, true, true, true) =&gt; Node::delete(target),
                        (_, _, _, _) =&gt; None,
                    },
                }
            }
        }
    }
</code></pre>
<p>Next we look at some other API's that the tree struct exposes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-apis"><a class="header" href="#additional-apis">Additional APIs</a></h1>
<p>Next we discusss additional public APIs built on top of our core <code>Tree</code> struct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-minimum"><a class="header" href="#tree-minimum">Tree minimum</a></h1>
<p>The <code>minimum</code> pub API returns the minimum entry in the tree if the tree is not empty. It call anoth-ther internal API called <code>min</code>. The <code>min</code> function accepts a reference to <code>Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;</code> 
and returns <code>OptionRc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;</code>. Its does so by going to the left of the passed in node 
reference as far as possible or returns current left's root node otherwise.</p>
<p>The tree <code>minimum</code> just calls the internal <code>min</code> function passing its root node's reference and
returns either returned <code>Node</code>'s (if found) key or <code>None</code> otherwise.</p>
<h3 id="below-are-the-public-minimum-and-internal-min-apis"><a class="header" href="#below-are-the-public-minimum-and-internal-min-apis">Below are the public <code>minimum</code> and internal <code>min</code> APIs.</a></h3>
<pre><code class="language-rust  ignore">
    //Returns the minimum key value (if any) or `None` otherwise
    //Delegates to internal min function
    pub fn minimum(&amp;self) -&gt; Option&lt;T&gt; {
        let node = self.root();
        match node {
            None =&gt; None,
            Some(ref inner) =&gt; Self::min(inner).map(|n| n.borrow().key.clone()),
        }
    }
</code></pre>
<blockquote>
<p><strong>Note</strong>: This is one place where we are using clone on T i.e. <code>key.clone()</code> above.</p>
</blockquote>
<pre><code class="language-rust  ignore">
    //Find the min - given a node. Result could be given node itself
    //if no more left branch is there
    fn min(node: &amp;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        match node.borrow().left_node() {
            Some(ref left_node) =&gt; Self::min(left_node),
            None =&gt; Some(Rc::clone(node)),
        }
    }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-exists"><a class="header" href="#tree-exists">Tree exists</a></h1>
<p>This API return <code>true</code> or <code>false</code> based on whether a <code>Node</code> corresponding to a input key reference
exists or not in the tree. It does so by recursively checking left or/and the right tree for the
presence of the key.</p>
<h3 id="following-is-the-function-definition"><a class="header" href="#following-is-the-function-definition">Following is the function definition:</a></h3>
<pre><code class="language-rust  ignore">    //Does a key exists in the tree?
    pub fn exists(&amp;self, key: &amp;T) -&gt; bool {
        match self.0 {
            Some(ref node) =&gt; {
                node.borrow().key() == key || {
                    let in_left = match node.borrow().left {
                        Some(ref tree) =&gt; Self::exists(&amp;tree.borrow(), key),
                        None =&gt; false,
                    };

                    let in_right = match node.borrow().right {
                        Some(ref tree) =&gt; Self::exists(&amp;tree.borrow(), key),
                        None =&gt; false,
                    };
                    in_left || in_right
                }
            }
            None =&gt; false,
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-identical"><a class="header" href="#tree-identical">Tree identical</a></h1>
<p>The tree <code>is_dentical</code> function checks if the current tree is identical to another tree that is
being passed in as input.</p>
<p>If both trees root's values match - then it proceeds to check whether or not left and right subtree-s are also identical or not. This is done recursively.</p>
<h3 id="following-is-the-definition"><a class="header" href="#following-is-the-definition">Following is the definition:</a></h3>
<pre><code class="language-rust ignore">//Is this tree is identical to other tree?
    pub fn is_identical(&amp;self, other: &amp;Self) -&gt; bool {
        match self.0 {
            Some(ref this) =&gt; match other {
                Tree(Some(ref that)) =&gt; {
                    if this.borrow().key == that.borrow().key {
                        let this_left = &amp;this.borrow().left;
                        let that_left = &amp;that.borrow().left;
                        let this_right = &amp;this.borrow().right;
                        let that_right = &amp;that.borrow().right;
                        let left_matched = match this_left {
                            Some(ref this_tree) =&gt; match that_left {
                                Some(ref that_tree) =&gt; {
                                    return Self::is_identical(
                                        &amp;this_tree.borrow(),
                                        &amp;that_tree.borrow(),
                                    );
                                }
                                None =&gt; false,
                            },
                            None =&gt; that_left.is_none(),
                        };
                        let right_matched = match this_right {
                            Some(ref this_tree) =&gt; match that_right {
                                Some(ref that_tree) =&gt; {
                                    return Self::is_identical(
                                        &amp;this_tree.borrow(),
                                        &amp;that_tree.borrow(),
                                    );
                                }
                                None =&gt; false,
                            },
                            None =&gt; that_right.is_none(),
                        };
                        left_matched &amp;&amp; right_matched
                    } else {
                        false
                    }
                }
                Tree(None) =&gt; false,
            },

            None =&gt; match other {
                Tree(Some(_)) =&gt; false,
                Tree(None) =&gt; true,
            },
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-contains"><a class="header" href="#tree-contains">Tree contains</a></h1>
<p>The tree <code>contains</code> API tells whether current tree is exactly similar to the input tree that is
passed in or a tree similar to the input tree exists somewhere in left or right half of the currenttree. It makes use of <code>is_identical</code> function of the tree and recursion to compute the result.</p>
<h3 id="below-is-the-function-defintion"><a class="header" href="#below-is-the-function-defintion">Below is the function defintion:</a></h3>
<pre><code class="language-rust  ignore">//Does this contains the other tree?
    pub fn contains(&amp;self, other: &amp;Self) -&gt; bool {
        match self {
            Tree(None) =&gt; match other {
                Tree(_) =&gt; false,
            },
            Tree(Some(ref this)) =&gt; match other {
                Tree(None) =&gt; true,
                that @ Tree(_) =&gt; {
                    if Self::is_identical(self, that) {
                        return true;
                    }
                    let left_contains = match this.borrow().left {
                        Some(ref tree) =&gt; Self::contains(&amp;tree.borrow(), that),
                        None =&gt; false,
                    };
                    let right_contains = match this.borrow().right {
                        Some(ref tree) =&gt; Self::contains(&amp;tree.borrow(), that),
                        None =&gt; false,
                    };
		     left_contains || right_contains
                }
            },
        }
    }		    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-iterator"><a class="header" href="#tree-iterator">Tree iterator</a></h1>
<p>Calling <code>tree.iter()</code> returns an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator</a> of <code>OptionM&lt;T&gt;</code> and <code>iterator.next()</code> returns the keys level wise. Also, <code>tree.iter()</code> can be 
called repeated since it does not consume the tree.</p>
<h3 id="following-are-the-relevant-implementation-details"><a class="header" href="#following-are-the-relevant-implementation-details">Following are the relevant implementation details:</a></h3>
<p>The <code>Iter</code> struct defintion:</p>
<pre><code class="language-rust  ignore">#[derive(Debug)]
pub struct Iter&lt;T: Ord + Default + Clone + std::fmt::Debug&gt; {
    next: Option&lt;VecDeque&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;&gt;,
}
</code></pre>
<p>The tree <code>iter</code> funtion:</p>
<pre><code class="language-rust  ignore">    //Get an iterator for the tree's keys
    //Remember - calling iter on the tree would not consume the tree
    //iterator.next would return Option&lt;T&gt;
    //T is cloned
    //Keys would would be returned level wise
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter {
            next: self.root().map(|node| {
                let mut next = VecDeque::new();
                next.push_front(node);
                next
            }),
        }
    }
</code></pre>
<p>The <code>Iterator</code> trait implementation:</p>
<pre><code class="language-rust ignore">impl&lt;T: Ord + Default + Clone + std::fmt::Debug&gt; Iterator for Iter&lt;T&gt; {
    type Item = T;
    //Level wise iterator
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.next {
            None =&gt; None,
            Some(ref mut queue) =&gt; {
                let popped = queue.pop_back();
                match popped {
                    None =&gt; None,
                    Some(ref node) =&gt; {
                        let node = node.borrow();
                        if let Some(ref left) = node.left_node() {
                            queue.push_front(Rc::clone(left));
                        }
                        if let Some(ref right) = node.right_node() {
                            queue.push_front(Rc::clone(right));
                        }
                        Some(node.key.clone())
                    }
                }
            }
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: We cloning T when calling <code>iterator.next()</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-into-iterator"><a class="header" href="#tree-into-iterator">Tree into iterator</a></h1>
<p>Unlike  <code>tree.iter()</code> <code>tree.into_iter()</code> returns an iterator of <code>Option&lt;T&gt;</code> that consumes the tree
elements one by one when called <code>next</code> on it. Also, every time <code>next</code> is called, the root of the
tree is popped.</p>
<h3 id="following-sre-the-revelvant-definitions"><a class="header" href="#following-sre-the-revelvant-definitions">Following sre the revelvant definitions:</a></h3>
<p><code>IntoIter</code> struct defintion:</p>
<pre><code class="language-rust  ignore">#[derive(Debug)]
pub struct IntoIter&lt;'a, T: Ord + Default + Clone + std::fmt::Debug&gt; {
    tree: Option&lt;&amp;'a mut Tree&lt;T&gt;&gt;,
}
</code></pre>
<p>Tree <code>into_iter</code> funtion:</p>
<pre><code class="language-rust ignore">//Returns an iterator that consumes the tree elements one by one
//when calling next on it
//Root of the tree is eviced when next is called on the iterator
pub fn into_iter(&amp;mut self) -&gt; IntoIter&lt;'_, T&gt; {
        IntoIter {
            tree: match self {
                Tree(None) =&gt; None,
                Tree(_) =&gt; Some(self),
            },
        }
    }
</code></pre>
<p>Iterator trait implementation for <code>IntoIter</code>:</p>
<pre><code class="language-rust  ignore">impl&lt;T: Ord + Default + Clone + std::fmt::Debug&gt; Iterator for IntoIter&lt;'_, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.tree {
            None =&gt; None,
            Some(ref mut tree) =&gt; match tree.0 {
                None =&gt; None,
                Some(ref mut node) =&gt; {
                    let key = node.borrow().key.clone();
                    tree.delete(&amp;key);
                    Some(key)
                }
            },
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-height"><a class="header" href="#tree-height">Tree height</a></h1>
<h3 id="tree-height-function"><a class="header" href="#tree-height-function">Tree <code>height</code> function:</a></h3>
<pre><code class="language-rust  ignore"> //Find the height of the tree
    pub fn height(&amp;self) -&gt; usize {
        let root = self.root();
        match root {
            None =&gt; 0,
            Some(ref node)
                if node.borrow().left_node().is_none() &amp; node.borrow().right_node().is_none() =&gt;
            {
                1
            }
            Some(ref node) =&gt; {
                let left_tree_height = node
                    .borrow()
                    .left
                    .as_ref()
                    .map(|tree| Self::height(&amp;tree.borrow()))
                    .unwrap_or(0);
                let right_tree_height = node
                    .borrow()
                    .right
                    .as_ref()
                    .map(|tree| Self::height(&amp;tree.borrow()))
                    .unwrap_or(0);
                1 + std::cmp::max(left_tree_height, right_tree_height)
            }
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lowest-common-ancestor-lca"><a class="header" href="#lowest-common-ancestor-lca">Lowest common ancestor (LCA)</a></h1>
<p>Here we present how to find the lowest common ancestor for two given keys. LCA is the 
immediate parent that the given keys share. Or the parent could be one the keys - if that 
key happens to the parent of the other given key.</p>
<p>The LCA would be in the left or right side of a node - if the node's key is bigger or 
smaller than both the given keys. If that condition trips - that would mean given keys 
are on the either side of the node or one of the keys is the node itself and the other 
would be beneath it.</p>
<h3 id="following-is-the-lca-implentation"><a class="header" href="#following-is-the-lca-implentation">Following is the LCA implentation:</a></h3>
<pre><code class="language-rust  ignore">//Return the lowest common ancestor for two given keys
    pub fn lowest_common_ancestor(&amp;self, this: &amp;T, that: &amp;T) -&gt; Option&lt;T&gt; {
        if let Some(ref root) = self.root() {
            let root = root.borrow();
            if root.key() &lt; this &amp;&amp; root.key() &lt; that {
                if let Some(ref right) = root.right {
                    return Self::lowest_common_ancestor(&amp;right.borrow(), this, that);
                } else {
                    return None;
                }
            } else if root.key() &gt; this &amp;&amp; root.key() &gt; that {
                if let Some(ref left) = root.left {
                    return Self::lowest_common_ancestor(&amp;left.borrow(), this, that);
                } else {
                    return None;
                }
            } else {
                return Some(root.key().clone());
            }
        } else {
            None
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nth-smallest"><a class="header" href="#nth-smallest">Nth smallest</a></h1>
<p>To find nth smallest key in the tree we go all the way to the left. Once we are there, we 
ask the question - is the current position is the nth position? If so, we return the node's key at that position. Otherwise, we move up - repeat the process.</p>
<h3 id="following-is-the-routine-for-finding-the-nth-smallest"><a class="header" href="#following-is-the-routine-for-finding-the-nth-smallest">Following is the routine for finding the nth smallest:</a></h3>
<pre><code class="language-rust  ignore">//Find nth smallest in the binary seach tree
    pub fn nth_smallest(&amp;self, nth: usize) -&gt; Option&lt;T&gt; {
        let mut current_pos = 0;
        let mut result = None;
        Self::nth_smallest_helper(self.root(), &amp;mut current_pos, nth, &amp;mut result);
        result
    }

    fn nth_smallest_helper(
        node: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
        current_pos: &amp;mut usize,
        nth: usize,
        result: &amp;mut Option&lt;T&gt;,
    ) {
       if let Some(inner) = node {
           Self::nth_smallest_helper(inner.borrow().left_node(), current_pos, nth, result);
            *current_pos += 1;
            if *current_pos == nth {
                *result = Some(inner.borrow().key().clone());
            }
          Self::nth_smallest_helper(inner.borrow().right_node(), current_pos, nth, result);
    	}
    }                           
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kth-smallest"><a class="header" href="#kth-smallest">Kth smallest</a></h1>
<p>Here we present the iterative solution to find the kth smallest number. To do that we 
maintain a stack. We keep going left as long as possible and keep pushing the nodes we 
encounter (to back step) to the stack. When the lowest node is found - we pop from the 
stack and increment our internal counter. We check if interanl counter equals to the kth 
value we are looking for - If so, we return the node's key. Otherwise we start going up - 
either by going to the right or popping up previous node entry in the stack.</p>
<h3 id="following-snippet-of-code-shows-how-we-get-the-kth-smallest-iteratively"><a class="header" href="#following-snippet-of-code-shows-how-we-get-the-kth-smallest-iteratively">Following snippet of code shows how we get the kth smallest iteratively:</a></h3>
<pre><code class="language-rust  ignore">    //kth smallest element - iterative
    pub fn kth_smallest(&amp;self, k: usize) -&gt; Option&lt;T&gt; {
        let mut curr = self.root();
        let mut stack = Vec::new();
        let mut n = 0;
        while curr.is_some() || !stack.is_empty() {
            while curr.is_some() {
                stack.push(curr.as_ref().cloned());
                curr = curr.and_then(|curr| curr.borrow().left_node());
            }
            curr = stack.pop().flatten();
            n += 1;
            if n == k {
                return curr.map(|curr| curr.borrow().key().clone());
            }
            curr = curr.and_then(|curr| curr.borrow().right_node());
	    }
        None
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-sorted-array"><a class="header" href="#from-sorted-array">From sorted array</a></h1>
<p>Here we present how to create a height balanced binary search tree from a sorted array. 
Height balanced BST is such that - height of subtrees in the left and right side of the 
root would not differ by more than 1. The algorithm we use is recursive.</p>
<p>We pick the mid point of the sorted array - make it the root of the tree. Then we - take 
half from next of the mid point till the end the array - make a recursive call to make the right subtree of them root. We do the same thing for left subtree - only difference is 
that this time we take the half from start of the array till the element before the mid 
point.</p>
<h3 id="following-is-the-implementation"><a class="header" href="#following-is-the-implementation">Following is the implementation:</a></h3>
<pre><code class="language-rust  ignore">//Create a height balanced tree from a sorted array
    //The array passed in gets mutated - its elements are replaced with default
    //values for type `T`
    pub fn from_sorted_array(array: &amp;mut [T]) -&gt; Option&lt;Self&gt; {
        fn wrap_tree&lt;T: Ord + Default + Clone + std::fmt::Debug&gt;(
            tree: Option&lt;Tree&lt;T&gt;&gt;,
        ) -&gt; Option&lt;Rc&lt;RefCell&lt;Tree&lt;T&gt;&gt;&gt;&gt; {
            match tree {
                None =&gt; None,
                tree @ Some(_) =&gt; tree.map(|tree| Rc::new(RefCell::new(tree))),
            }
        }
        fn from_array&lt;T: Ord + Default + Clone + std::fmt::Debug&gt;(
            array: &amp;mut [T],
            left: i32,
            right: i32,
        ) -&gt; Option&lt;Tree&lt;T&gt;&gt; {
            if left &gt; right {
                return None;
            } else {
                let mid = left + (right - left) / 2;
                let tree = Tree::new(std::mem::take(&amp;mut array[mid as usize]));
                let right = from_array(array, mid + 1, right);
                let left = from_array(array, left, mid - 1);
                let mut right = wrap_tree(right);
                let mut left = wrap_tree(left);
                if let Some(ref mut root) = tree.root() {
                    root.borrow_mut().left = left.as_ref().cloned();
                    root.borrow_mut().right = right.as_ref().cloned();
                }
                if let Some(ref mut left) = left {
                    if let Some(ref mut tree_node) = left.borrow_mut().root() {
                        tree_node.borrow_mut().parent = tree
                            .root()
                            .as_ref()
                            .map(|root| Rc::downgrade(&amp;Rc::clone(root)));
                    }
                }
                if let Some(ref mut right) = right {
                    if let Some(ref mut tree_node) = right.borrow_mut().root() {
                        tree_node.borrow_mut().parent = tree
                            .root()
                            .as_ref()
                            .map(|root| Rc::downgrade(&amp;Rc::clone(root)));
                    }
                }
                return Some(tree);
            }
        }
        from_array(array, 0, (array.len() - 1) as i32)
    }
</code></pre>
<blockquote>
<p><strong>Note</strong>: We are making use of nested functions above.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-validation"><a class="header" href="#tree-validation">Tree validation</a></h1>
<p>Below we present the implementation of an iterative algoritm to validate the binary search tree. The idea here is to go the left most node - and then traverse the tree in order. 
When traversing tree in order - we expect every next element to be bigger than the previous element and lesser than the root element. When we cross the root - we want every element 
be greater than the root and its previous element.</p>
<p>###Following function achieves the same:</p>
<pre><code class="language-rust  ignore">//Validate the if the tree is valid
    //We use an interative process here
    pub fn validate(&amp;self) -&gt; bool {
        match self.0 {
            None =&gt; true,
            Some(ref root) =&gt; {
                let mut current = Some(Rc::clone(root));
                let mut stack = Vec::new();
                let mut previous = None;
                let mut crossed_root = false;
                let mut first = Some(false);
                while current.is_some() || !stack.is_empty() {
                    while current.is_some() {
                        stack.push(current.as_ref().cloned());
                        current = current.and_then(|inner| inner.borrow().left_node());
                    }
                    current = stack.pop().and_then(|popped| popped);
                    //Has moved to the right side of the tree
                    if !crossed_root {
                        crossed_root = current.as_ref().map(|curr| Rc::ptr_eq(curr, root)).unwrap();
                        if let Some(first) = first.as_mut() {
                            *first = crossed_root;
                        }
                    }
                    match previous {
                        None =&gt; previous = current.as_ref().map(Rc::clone),
                        Some(ref prev) =&gt; match current.as_ref().map(|curr| {
                            (
                                crossed_root,
                                &amp;mut first,
                                curr.borrow().key() &gt; prev.borrow().key(),
                                curr.borrow().key() &lt; root.borrow().key(),
                            )
                        }) {
                            Some((false, Some(false), true, true)) =&gt; {
                                previous = current.as_ref().map(Rc::clone)
                            }
                            Some((true, Some(true), true, false)) =&gt; {
                                if let Some(first) = first.as_mut() {
                                    *first = false;
                                }
                                previous = current.as_ref().map(Rc::clone)
                            }
                            Some((true, Some(false), true, false)) =&gt; {
                                previous = current.as_ref().map(Rc::clone)
                            }
                            _ =&gt; return false,
                        },
                    }
                    current = current.and_then(|inner| inner.borrow().right_node());
                }
                true
            }
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-update"><a class="header" href="#tree-update">Tree update</a></h1>
<p>We can update the value of any node in the binary search tree. We search the key to be 
updated by using <code>Iterator</code> find method any mutate its value.</p>
<h3 id="tree-update-implementation"><a class="header" href="#tree-update-implementation">Tree update implementation</a></h3>
<pre><code class="language-rust  ignore"> //Update a node key in the tree
    pub fn update(&amp;mut self, key: &amp;T, new_val: T) -&gt; bool {
        let mut node = self.node_iter().find(|node| node.borrow().key() == key);
        match node {
            None =&gt; false,
            Some(ref mut inner) =&gt; {
                inner.borrow_mut().replace_key(Some(new_val));
                true
            }
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dubley-linkedlist"><a class="header" href="#dubley-linkedlist">Dubley linkedlist</a></h1>
<p>Here we implement a doubly link with quite a rich set of APIs. We provide following apis:</p>
<ul>
<li><code>push_front</code></li>
<li><code>pop_front</code></li>
<li><code>push_back</code></li>
<li><code>pop_back</code></li>
<li><code>delete</code></li>
<li><code>iter</code> - Returns a double ended iterator. Stops returning values when pointers meet. Immutable,
the list remains intact.</li>
<li><code>inter_into</code> - Returns a double ended iterator that consumes the elements. List becomes empty, oncethe iterator is fully traversed.</li>
</ul>
<h2 id="lets-look-at-the-node-and-list-definitions-next"><a class="header" href="#lets-look-at-the-node-and-list-definitions-next">Let's look at the <code>Node</code> and <code>List</code> definitions next.</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-and-list"><a class="header" href="#node-and-list">Node and List</a></h1>
<p>Below we present the defintion of <code>Node</code>. Member definitions are quite intuitive. We maintain a weak
previous reference to the preceeing <code>Node</code>.</p>
<pre><code class="language-rust  ignore">#[derive(Debug, Default)]
struct Node&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; {
    key: T,
    next: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
    prev: Option&lt;Weak&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
}
//New up a new node with a value
impl&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; Node&lt;T&gt; {
    pub fn new(key: T) -&gt; Self {
        Self {
            key,
            next: None,
            prev: None,
        }
    }
}

//We implement `From` trait to wrap  up a node in RefCell and Rc
impl&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; From&lt;Node&lt;T&gt;&gt;
    for Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;
{
    fn from(node: Node&lt;T&gt;) -&gt; Self {
        Some(Rc::new(RefCell::new(node)))
    }
}
</code></pre>
<p>Following is the defintion of <code>List</code>:</p>
<pre><code class="language-rust  ignore">#[derive(Debug)]
pub struct List&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; {
    head: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
    tail: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push-front-and-push-back"><a class="header" href="#push-front-and-push-back">Push front and push back</a></h1>
<h3 id="push-to-the-front-of-the-list"><a class="header" href="#push-to-the-front-of-the-list">Push to the front of the list:</a></h3>
<pre><code class="language-rust  ignore">//Push to the front of the list
    pub fn push_front(&amp;mut self, key: T) {
        let node = Node::new(key).into();
        match self.head {
            None =&gt; {
                self.head = node;
                self.tail = self.head.as_ref().map(Rc::clone);
            }
            Some(ref mut head) =&gt; {
                head.borrow_mut().prev = node.as_ref().map(|node| Rc::downgrade(&amp;Rc::clone(node)));
                self.head = node.map(|node| {
                    node.borrow_mut().next = Some(Rc::clone(head));
                    node
                });
            }
        }
    }
</code></pre>
<p>Above, we create a new node, set it as head and tail - if the list is empty. Otherwise, make the new node the head of the list, make the existing head to point to it via a weak reference and make new node's <code>next</code> point to the existing head.</p>
<h3 id="push-to-the-back-of-the-list"><a class="header" href="#push-to-the-back-of-the-list">Push to the back of the list:</a></h3>
<p>Again, we set the newly created node as the <code>head</code> and <code>tail</code> of the list - if the list is empty.
Otherwise, make the new node point to existing tail via a weak reference, make the existing tail to
point to new node and set new node as the tail of the list.</p>
<h3 id="code-for-pushing-to-the-back-of-the-list"><a class="header" href="#code-for-pushing-to-the-back-of-the-list">Code for pushing to the back of the list:</a></h3>
<pre><code class="language-rust  ignore">//Push to the back of the list
    pub fn push_back(&amp;mut self, key: T) {
        let mut node = Node::new(key).into();
        match self.tail {
            None =&gt; {
                self.head = node;
                self.tail = self.head.as_ref().map(Rc::clone);
            }
            Some(ref mut tail) =&gt; {
                self.tail = node.take().map(|node| {
                    node.borrow_mut().prev = Some(Rc::downgrade(&amp;Rc::clone(tail)));
                    tail.borrow_mut().next = Some(Rc::clone(&amp;node));
                    node
                });
            }
        }
    }
</code></pre>
<p>Next, we would look at <code>pop_front</code> and <code>pop_back</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop-front-and-pop-back"><a class="header" href="#pop-front-and-pop-back">Pop front and pop back</a></h1>
<p>While popping from the front of the list, we take out existing head, make it's next the new head of
the list. While doing so, we also take out previous pointer of the new head, which was pointing at
the outgoing head. If the new head turns out to be <code>None</code> - we also set list tail to <code>None</code>. We
return the outgoing head's content.</p>
<h3 id="below-is-the-code-for-popping-from-the-front"><a class="header" href="#below-is-the-code-for-popping-from-the-front">Below is the code for popping from the front:</a></h3>
<pre><code class="language-rust  ignore">    //Pop out from the front of the list
    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        match self.head.take() {
            None =&gt; None,
            Some(ref mut head) =&gt; {
                self.head = head.borrow_mut().next.take().map(|next| {
                    next.borrow_mut().prev.take();
                    next
                });
                if self.head.is_none() {
                    self.tail.take();
                }
                //Use of default
                Some(head.take().key)
            }
        }
    }
</code></pre>
<p>While popping from the back, we take out the list's tail, convert the tail's previous pointer to a
strong reference, make the previous the new tail of the list. If the new tail turns out to be <code>None</code>
we set head of the list to <code>None</code> as well. Finally, we return the outgoing tail's content from the
call.</p>
<h3 id="belwo-is-the-code-for-popping-from-the-back"><a class="header" href="#belwo-is-the-code-for-popping-from-the-back">Belwo is the code for popping from the back:</a></h3>
<pre><code class="language-rust  ignore">   //Pop out from the back of the list
    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        match self.tail.take() {
            None =&gt; None,
            Some(ref mut tail) =&gt; {
                self.tail = tail.borrow().prev.as_ref().and_then(|prev| {
                    prev.upgrade().map(|prev| {
                        prev.borrow_mut().next = None;
                        prev
                    })
                });
                if self.tail.is_none() {
                    self.head.take();
                }
                //Use of default
                Some(tail.take().key)
            }
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-delete"><a class="header" href="#list-delete">List delete</a></h1>
<p>While deleting from a list, we need to consider two cases - is the node being deleted the last or
first node or is an inner node? The way we handle them is different. To make things simple, we have
implemented few internal helper functions. We turn to those helper functions in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-helpers"><a class="header" href="#delete-helpers">Delete helpers</a></h1>
<p>To figure out whether a target node that is being deleted is the first or last node in the list,
we compare it to the head or the tail of the list. This comparsion we do by using the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.ptr_eq">ptr_eq</a>.</p>
<h3 id="below-are-the-codes-for-achieving-the-same"><a class="header" href="#below-are-the-codes-for-achieving-the-same">Below are the codes for achieving the same:</a></h3>
<pre><code class="language-rust  ignore">    //Is the passed in node reference the first in the list?
    fn is_first(&amp;self, node: &amp;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;) -&gt; bool {
        match self.head {
            None =&gt; false,
            Some(ref head) =&gt; Rc::ptr_eq(head, node),
        }
    }

    //Is the passed in node reference the last in the list?
    fn is_last(&amp;self, node: &amp;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;) -&gt; bool {
        match self.tail {
            None =&gt; false,
            Some(ref tail) =&gt; Rc::ptr_eq(tail, node),
        }
    }
</code></pre>
<p>One we have figured that a target node that is being deleted is either first or last, its just a
matter of calling <code>pop_front</code> or <code>pop_back</code> accordingly.</p>
<h3 id="deleting-a-inner-target-node"><a class="header" href="#deleting-a-inner-target-node">Deleting a inner target node:</a></h3>
<p>To delete inner target node we first get a handles to its previous and next nodes. Once we find them,
we need to rewire the linkages appropriately.</p>
<p>We clone the the outgoing target's previous pointer, which is a weak pointer reference, set it as theprevious pointer of the outgoing node's next node.</p>
<p>We upgrade previous (<code>prev</code>) weak  pointer to get a strong refernce to get to previous node and set 
next's cloned reference as its next. Then we return the content of outgoing target node.</p>
<p>Following is snippet for deleting an inner node:</p>
<pre><code class="language-rust  ignore">//Delete a node that has previous and next
    fn delete_inner(&amp;mut self, target: &amp;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;) -&gt; Option&lt;T&gt; {
        let prev = target.borrow_mut().prev.take();
        let next = target.borrow_mut().next.take();
        if let Some(ref next) = next {
            next.borrow_mut().prev = prev.as_ref().cloned();
        }
        if let Some(ref prev) = prev {
            if let Some(prev) = prev.upgrade() {
                prev.borrow_mut().next = next.as_ref().map(Rc::clone);
            }
        }
        Some(target.take().key)
    }
</code></pre>
<p>Now, that we know how the helpers work, we present the actual <code>delete</code> function - which is quite
simple.</p>
<h3 id="delete-public-api"><a class="header" href="#delete-public-api">Delete public API:</a></h3>
<pre><code class="language-rust  ignore">    //Delete a key from the list. We try to find the by using iterator `find` method.
    //If found - we check if it is the first or last key in the list. If the found node
    //happens to be first or last - we call pop_front or pop_back as required.
    //If the key is in between head and and tail - the deletion is handled accordingly.
    pub fn delete(&amp;mut self, key: &amp;T) -&gt; Option&lt;T&gt; {
        match self.node_iter().find(|node| node.borrow().key == *key) {
            None =&gt; None,
            Some(ref target) =&gt; match (self.is_first(target), self.is_last(target)) {
                (true, true) | (true, false) =&gt; self.pop_front(),
                (false, true) =&gt; self.pop_back(),
                (_, _) =&gt; self.delete_inner(target),
            },
        }
    }
</code></pre>
<blockquote>
<p><strong>Note</strong>: To find the target node that is being deleted, we are making use of <code>Iterator</code>'s <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find">find</a> api. We have not talked about
<code>List</code>'s iterator implementation yet - which we will turn to next.
`</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-iterators"><a class="header" href="#list-iterators">List iterators</a></h1>
<p>We implement two variants of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iteratots</a> for our list - one that evicts elements from the the list while the iterator is being traversed and the
other that does not mutate the underlying list. Both these variants can be traversed from the front
as well from the back because we implement <a href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html">double ended iterator</a> for them.</p>
<p>First we will look at mutable variant - because if pretty simple.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-iterator"><a class="header" href="#mutable-iterator">Mutable iterator</a></h1>
<p>We iterate through iterator elements by calling <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next">next</a> on it - this means we need to maintain the iterator's state. Folloing is a
struct that mutabley borrows the underlying list and stores it. The life time paramter 'a is there 
because we are holding a reference to the list - we don't own the list. An <code>IntoIterator</code> instance 
can exist only as long as unerlying list struct instance is alive. The iterator can not outlive the
list struct instance that it is borrowing.</p>
<pre><code class="language-rust  ignore">pub struct IntoIterator&lt;'a, T: std::fmt::Debug + Default + Clone + PartialEq&gt; {
    list: &amp;'a mut List&lt;T&gt;,
}
</code></pre>
<h3 id="getting-an-intoiterator-instance"><a class="header" href="#getting-an-intoiterator-instance">Getting an IntoIterator instance:</a></h3>
<p>We have added following function to the <code>List</code> struct to return an <code>IntoIterator</code> instance. While
returning the <code>IntoIterator</code> struct instance - list passes it its own mutable self reference. And
because we have a mutable reference to the list - we can modify it as long as we return it back in
some shape - either intact or altered.</p>
<pre><code class="language-rust  ignore">pub fn into_iter(&amp;mut self) -&gt; IntoIterator&lt;'_, T&gt; {
   //Taking a mutable reference to the list
   IntoIterator { list: self }
}
</code></pre>
<blockquote>
<p><strong>Node</strong>: We are breaking rust's convention here. Idiomatic rust consumes the collection as a
whole if elements are dropped while iterating. Here we are not destroying the list though post
iteration it bcomes empty. We could have consumed the list instead.</p>
</blockquote>
<p>Now that we have struct that we have named <code>IntoIterator</code> and it has a mutable list inside it - can
we iterate over the elements inside the list? Not yet. We have not added the iterator behaviour to
our struct yet. We need to implement the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a> trait for our <code>IntoIterator</code> struct for that. Whichis what we will do next.</p>
<blockquote>
<p><strong>Note</strong>: The <code>Iterator</code> trait has quite a bunch of methods defined in it. But we need to 
implement only the <code>next</code> method of it because rests are implemented based on <code>next</code>.</p>
</blockquote>
<h3 id="implement-iterator-for-intoiterator"><a class="header" href="#implement-iterator-for-intoiterator">Implement Iterator for IntoIterator:</a></h3>
<pre><code class="language-rust  ignore">//Iterator that consumes the list elements from the front
impl&lt;'a, T: std::fmt::Debug + Default + Clone + PartialEq&gt; Iterator for IntoIterator&lt;'a, T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_front()
    }
}
</code></pre>
<p>Our implementation could not have been any more simpler than this - we just pop the elements from
the front! </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-back-iterator"><a class="header" href="#mutable-back-iterator">Mutable back iterator</a></h1>
<p>Our <code>IntoIterator</code> implements <code>Iterator</code> - hence we can iterate forward traversing the elements.
What if we wanted to traverse the elements back? For that we have to implement <a href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html">DoubleEndedIterator</a>. To implement double ended
iterator it is mandatary that we implement <code>Iterator</code> first for our struct - whcih we have already
done.</p>
<p>To implement <code>DoubleEndedIterator</code> we need to provide an implementation of the <code>next_back</code> method
and our implementation is no-brainer - we just call pop_back on our list!</p>
<h3 id="following-is-our-implementation-of-doubleendediterator"><a class="header" href="#following-is-our-implementation-of-doubleendediterator">Following is our implementation of DoubleEndedIterator:</a></h3>
<pre><code class="language-rust  ignore">impl&lt;'a, T: std::fmt::Debug + Default + Clone + PartialEq&gt; DoubleEndedIterator
    for IntoIterator&lt;'a, T&gt;
{
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.list.pop_back()
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immutable-bi-directional-iterator"><a class="header" href="#immutable-bi-directional-iterator">Immutable bi-directional iterator</a></h1>
<p>We want to be able to iterate the elemnts of our list as many times as we want - but our list
should not change. We take an iterator from out list, travese the elements, exhaust the iterator,
take another one and so on. This where immutable iterator comes in. Immutable iterator generally
provides an access to <code>Option&lt;&amp;T&gt;</code>. We can not alter underlying <code>List</code> with an immutable shared
<code>Option&lt;&amp;T&gt;</code>. We can read or may be clone it - if clone is supported for <code>T</code>.</p>
<p>In our case, we are breaking rust convention again - instead of returning <code>Option&lt;&amp;T&gt;</code>, we are
going to return <code>Option&lt;T&gt;</code>. But that does not change anything about the immutability of our
underlying <code>List</code> - it would still remain intact. We clone our <code>&amp;T</code> and return <code>Option&lt;T&gt;</code>.</p>
<p>The reason for returning <code>Option&lt;T&gt;</code> and not <code>Option&lt;&amp;T&gt;</code> is that our <code>T</code>s are burried deep inside
of <code>RefCell</code>s which themselves are insides' of <code>Rc</code>s. Its seems pretty damn hard to give a <code>&amp;T</code> out
from <code>Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;</code> - I have not figured it out yet - not sure if that would be possible 
without resorting to unsafe rust.</p>
<p>Hence we stick it our good friend - <code>Option&lt;T&gt;</code>.</p>
<p>In the previous section - we have implemented <code>DoubleEndedIterator</code> when we had a mutable referece
to our underlying <code>List</code>. It was easy because we made use of <code>pop_front</code> and <code>pop_back</code> and we were
able get elements from right ends in right order.</p>
<p>In the immutable case, we don't want to maintain a mutable reference to our underlying list. We
aslo want our immutable iterator to be able traverse forward as well as backward and while doing so, we don't want to trample each other. In another words, while calling <code>next</code>, we don't want our
iterator to return elements which we have already seen by calling <code>next_back</code> and vice versa.</p>
<p>Again, when we call <code>iter</code> on our list to get a bi-directional iterator - the struct that gets 
returned should be simple enough and should not have lot of code to achieve the funtionality that 
we want. We want to handle case whether to return an element or not, because it may already have 
been returned by <code>next_back</code> or <code>next</code>, internally. We want that piece of logic to reside in some 
other struct. Ok, enough talk. Let's get down to code.</p>
<h3 id="immutable-iterator-struct-defintion-that-caller-gets"><a class="header" href="#immutable-iterator-struct-defintion-that-caller-gets">Immutable iterator struct defintion that caller gets:</a></h3>
<pre><code class="language-rust  ignore">pub struct Iter&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; {
    nodes: NodeIterator&lt;T&gt;,
}
</code></pre>
<p>Above struct holds an instance of <code>NodeIterator</code> that has head and tail of the list as members.</p>
<h3 id="iterator-trait-implementation-for-iter"><a class="header" href="#iterator-trait-implementation-for-iter">Iterator trait implementation for <code>Iter</code>:</a></h3>
<pre><code class="language-rust  ignore">//Itearor that returns Option&lt;T&gt;
//Values are cloned
//Underlying list remain intact
impl&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; Iterator for Iter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.nodes
            .next()
            .as_ref()
            .map(|next| next.borrow().key.clone())
    }
}
</code></pre>
<h3 id="doubleendediterator-implementation"><a class="header" href="#doubleendediterator-implementation">DoubleEndedIterator implementation:</a></h3>
<pre><code class="language-rust  ignore">//Iterate back 
//Calling next_back should not returned elements seen by calling next and vice versa
impl&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; DoubleEndedIterator for Iter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.nodes
            .next_back()
            .as_ref()
            .map(|prev| prev.borrow().key.clone())
    }
}
</code></pre>
<p>Our iterator and double ended iterator implementations are simple enough and much of the logic is 
hidden inside <code>NodeIterator</code>. But it turns out our <code>NodeIterator</code> is also not very complex at all.</p>
<h3 id="nodeiterator-struct-defintion"><a class="header" href="#nodeiterator-struct-defintion">NodeIterator struct defintion:</a></h3>
<pre><code class="language-rust  ignore">//This struct holds head and tail of the list
//ptr_crossed flag indicates whether front and back iterators crossed each other
struct NodeIterator&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; {
    head: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
    tail: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
    ptr_crossed: bool,
}
</code></pre>
<h3 id="iterator-trait-implementation-for-nodeiterator"><a class="header" href="#iterator-trait-implementation-for-nodeiterator">Iterator trait implementation for NodeIterator:</a></h3>
<p><code>NodeIterator</code> struct has references to head and tail of the list. These references move forward 
and backward as we call <code>next</code> and <code>next_back</code>. When calling <code>next</code> - we see if the <code>ptr_crossed</code> 
flag is set - if set we return <code>None</code>, if not set - we proceed forward - check if we are returing 
the same element that tail is pointing at - if so, if set the <code>ptr_crossed</code> flagged is set so that  calling <code>next_back</code> does not return any more elements. That's all to it. <code>DoubleEndedIteraror</code> 
implementation does same thing just that it looks at the head pointer.</p>
<pre><code class="language-rust  ignore">impl&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; Iterator for NodeIterator&lt;T&gt; {
    type Item = Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.head {
            Some(_) =&gt; {
                match self
                    .head
                    .as_ref()
                    .map(|next| (Rc::clone(next), next.borrow().next.as_ref().map(Rc::clone)))
                {
                    None =&gt; None,
                    Some(this_and_next) =&gt; match self.ptr_crossed {
                        true =&gt; None,
                        false =&gt; {
                            let this = this_and_next.0;
                            let next = this_and_next.1;
                            self.ptr_crossed = self
                                .tail
                                .as_ref()
                                .map(|tail| Rc::ptr_eq(&amp;this, tail))
                                .unwrap_or(false);
                            self.head = next;
                            Some(this)
                        }
                    },
                }
            }
            None =&gt; None,
        }
    }
}
</code></pre>
<h3 id="doubleendediterator-implementation-for-nodeiterator"><a class="header" href="#doubleendediterator-implementation-for-nodeiterator">DoubleEndedIterator implementation for NodeIterator:</a></h3>
<pre><code class="language-rust  ignore">impl&lt;T: std::fmt::Debug + Default + Clone + PartialEq&gt; DoubleEndedIterator for NodeIterator&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.tail {
            Some(_) =&gt; {
                match self.tail.as_ref().map(|tail| {
                    (
                        Rc::clone(tail),
                        tail.borrow()
                            .prev
                            .as_ref()
                            .cloned()
                            .and_then(|prev| prev.upgrade()),
                    )
                }) {
                    None =&gt; None,
                    Some(this_and_prev) =&gt; match self.ptr_crossed {
                        true =&gt; None,
                        false =&gt; {
                            let this = this_and_prev.0;
                            let prev = this_and_prev.1;
                            self.ptr_crossed = self
                                .head
                                .as_ref()
                                .map(|head| Rc::ptr_eq(&amp;this, head))
                                .unwrap_or(false);
                            self.tail = prev;
                            Some(this)
                        }
                    },
                }
            }
            None =&gt; None,
        }
    }
} 
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/doubley_linked_list/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting-algoriths"><a class="header" href="#sorting-algoriths">Sorting algoriths</a></h1>
<p>We present sorting algorithms in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble sort</a></h1>
<p>Bubble sort algorithm starts with left most item in the given array and compares it to the element next to it and swaps them if next is smaller than the previous. Then it starts with the next item( irrespective of whether it was swapped or not in the previous step) and 
compares with it's next and the process is continued. In the first pass, the comparison and swapping (if necessary) goes all the way till the end of the array and the biggest element in the array lands in the right most position. Again second pass starts with the left most element, puts next bigger element in the array in one position ahead of the biggest 
element. We maintain a <code>boolean</code> flag to avoid further unnecessary iterations if no 
swapping was done in the previous pass (because array is already sorted).</p>
<h3 id="following-is-the-bubble-sort-implementation"><a class="header" href="#following-is-the-bubble-sort-implementation">Following is the bubble sort implementation:</a></h3>
<pre><code class="language-rust  ignore">///Bubble sort implementation

pub fn sort&lt;T: PartialOrd&gt;(items: &amp;mut [T]) {
    let mut swapped = true;
    while swapped {
        swapped = false;
        let mut i = 0;
        for j in 0..items.len() - 1 - i {
            if items[j] &gt; items[j + 1] {
                items.swap(j, j + 1);
                swapped = true;
                i += 1;
            }
        }
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/tree/master/bubblesort/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insertion-sort"><a class="header" href="#insertion-sort">Insertion sort</a></h1>
<p>In insertion sort - we presume the item's array to be in two parts - left part which is 
presumed to be sorted and the rest - which is supposed to be unsorted. We pick up the 
unsorted elements one by one and place them in their aprropriate positions in the left 
sorted part untill whole unsorted part becomes empty - when the array is fully sorted.</p>
<p>The sorted part starts with just one element i.e. the first element - which is sorted 
in itself. Proceeding with second element onwards - we keep growing the sorted part. We 
are done when unsorted part becomes exhausted.</p>
<h3 id="following-is-the-insertion-sort-algorithm-implementation"><a class="header" href="#following-is-the-insertion-sort-algorithm-implementation">Following is the insertion sort algorithm implementation:</a></h3>
<pre><code class="language-rust  ignore">///Insertion sort implementation

pub fn sort&lt;T: PartialOrd&gt;(items: &amp;mut [T]) {
    for pos in 1..items.len() {
        let mut i = pos;
        while i &gt; 0 &amp;&amp; items[i] &lt; items[i - 1] {
            items.swap(i, i - 1);
            i -= 1;
        }
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/insertionsort/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selection-sort"><a class="header" href="#selection-sort">Selection sort</a></h1>
<p>In selection sort, we start at the beginning of the item's array, look at the rest of array to find the index of any element that could be the smallest the whole array. If found, we we swap the smallest with the element at the first position of the array. Then we look at 
the second element of the array - and try to find its replacement - if any. This process 
continues till we look at all the elements till the element before the last element.</p>
<h3 id="below-is-the-insertion-sort-implementation"><a class="header" href="#below-is-the-insertion-sort-implementation">Below is the insertion sort implementation:</a></h3>
<pre><code class="language-rust  ignore">///Selection sort implementation
  
pub fn sort&lt;T: PartialOrd&gt;(items: &amp;mut [T]) {
    for curr_item_index in 0..items.len() - 1 {
        let mut min_index_in_rest = curr_item_index;
        for next in (curr_item_index + 1)..items.len() {
            if items[next] &lt; items[min_index_in_rest] {
                min_index_in_rest = next;
            }
        }
        if min_index_in_rest != curr_item_index {
            items.swap(curr_item_index, min_index_in_rest);
        }
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/selectionsort/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merge-sort"><a class="header" href="#merge-sort">Merge sort</a></h1>
<p>We present the merge sort merge sort algorithm in this section. Merge sort is is divide and conquer algorithm - We keep dividing the input array (in memory) until each division is no longer than 1 element each. At this point all divinsions are sorted in themselves. Then we call the merge procedure. At this point we need an auxiliary  array - to hold the merged 
halves. From the auxiliary array - we copy the contents back to the original array picking next smaller elements. We don't expect the element type <code>T</code> to be clonable - but we need it to have a <code>Default::default</code> value - because rust does not like holes in memory.</p>
<p>Following is the implementation:</p>
<pre><code class="language-rust  ignore">///Merge sort implementation
pub fn sort&lt;'a, T: PartialOrd + Default&gt;(items: &amp;'a mut [T]) -&gt; &amp;'a [T] {
    if items.len() == 0 {
        return items;
    }
    let mut aux = Vec::with_capacity(items.len());
    //Put default value - since don't expect `T` to be clone - we
    //can not use Vec `fill`
    for _ in 0..items.len() {
        aux.push(T::default());
    }
    mergesort(items, 0, items.len() - 1, &amp;mut aux);
    items
}
pub fn mergesort&lt;T: PartialOrd + Default&gt;(
    items: &amp;mut [T],
    left: usize,
    right: usize,
    aux: &amp;mut Vec&lt;T&gt;,
) {
    if right - left &lt; 1 {
        return;
    }
    let mid = left + (right - left) / 2;
    mergesort(items, left, mid, aux);
    mergesort(items, mid + 1, right, aux);
    if items[mid] &lt;= items[mid + 1] {
        return;
    }
    merge(items, left, mid, right, aux);
}
pub fn merge&lt;T: PartialOrd + Default&gt;(
    items: &amp;mut [T],
    left: usize,
    mid: usize,
    right: usize,
    aux: &amp;mut Vec&lt;T&gt;,
) {
    //Copy elements to the auxiliary array
    for i in left..=right {
        aux.insert(i, std::mem::take(&amp;mut items[i]));
    }
    //Start of left half
    let mut left_index = left;
    //Start of right half
    let mut right_index = mid + 1;
    //From left to right all the way
    for item_index in left..=right {
        //Left half got exhausted
        //Copy what we have in the auxilary array to the items array
        if left_index &gt; mid {
            items[item_index] = std::mem::take(&amp;mut aux[right_index]);
            right_index += 1;
        //Right half exhausted
        } else if right_index &gt; right {
            items[item_index] = std::mem::take(&amp;mut aux[left_index]);
            left_index += 1;
        } else if aux[left_index] &lt; aux[right_index] {
            items[item_index] = std::mem::take(&amp;mut aux[left_index]);
            left_index += 1;
        } else {
            items[item_index] = std::mem::take(&amp;mut aux[right_index]);
            right_index += 1;
        }
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/mergesort/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-sort"><a class="header" href="#quick-sort">Quick sort</a></h1>
<p>In this section we present the implementtion of quick sort algorithm. Quick sort is an efficient 
sorting technique that uses no extra storage and can perform at <code>nlog(n)</code> time when the array 
elements are randomly placed. </p>
<p>Here we randomly select left, right or middle element as the pivot while the algorithm is process-  ing sub arrays.</p>
<h3 id="following-is-the-implementation-1"><a class="header" href="#following-is-the-implementation-1">Following is the implementation:</a></h3>
<pre><code class="language-rust  ignore">
Please ask your administrator.
///Implementation of Quick Sort algorithm
use rand::Rng;

pub fn quicksort&lt;T: PartialOrd&gt;(array: &amp;mut [T]) {
    let mut rng = rand::thread_rng();
    sort(array, 0, array.len() - 1, &amp;mut rng);
}
//Uses the right most element as pivot
#[inline]
fn right_as_pivot&lt;T: PartialOrd&gt;(array: &amp;mut [T], left: usize, right: usize) -&gt; usize {
    let mut i = left;
    for j in left..right {
        if array[j] &lt;= array[right] {
            array.swap(i, j);
            i += 1;
        }
    }
    array.swap(i, right);
    i
}
//Uses left most element as the as pivot
#[inline]
fn left_as_pivot&lt;T: PartialOrd&gt;(array: &amp;mut [T], left: usize, right: usize) -&gt; usize {
    let mut i = right;
    for j in (left + 1..=right).rev() {
        if array[j] &gt; array[left] {
            array.swap(i, j);
            i -= 1;
        }
    }
    array.swap(i, left);
    i
}
//Uses left most element as the as pivot
#[inline]
fn mid_as_pivot&lt;T: PartialOrd&gt;(array: &amp;mut [T], left: usize, right: usize) -&gt; usize {
    let mid = left + (right - left) / 2;
    array.swap(left, mid);
    let mut i = right;
    for j in (left + 1..=right).rev() {
        if array[j] &gt; array[left] {
            array.swap(i, j);
            i -= 1;
        }
    }
    array.swap(i, left);
    i
}

//Recursive parttion sort algorithm

fn sort&lt;T: PartialOrd&gt;(array: &amp;mut [T], left: usize, right: usize, random: &amp;mut impl Rng) {
    if left &lt; right {
        let partition = partition(array, left, right, random);
        if array[..partition].len() &gt; 1 {
            sort(array, left, partition - 1, random);
        }
        if array[partition + 1..].len() &gt; 1 {
            sort(array, partition + 1, right, random);
        }
    }
}

///Parttion the array segments using either left or right most elements as
///the pivots randomly.
#[inline]
fn partition&lt;T: PartialOrd&gt;(
    array: &amp;mut [T],
    left: usize,
    right: usize,
    random: &amp;mut impl Rng,
) -&gt; usize {
    if random.gen::&lt;bool&gt;() {
        left_as_pivot(array, left, right)
    } else if random.gen::&lt;bool&gt;() {
        right_as_pivot(array, left, right)
    } else {
        mid_as_pivot(array, left, right)
    }
}

#[cfg(test)]
mod tests {
    use super::quicksort;
    use rand::Rng;
    #[test]
    fn quicksort_test() {
        let mut runs = 50000;
        loop {
            let mut array: [u16; 20] = [0; 20];
            rand::thread_rng().fill(&amp;mut array);
            quicksort(&amp;mut array);
            if !is_sorted(&amp;array) {
                panic!(&quot;Array is not sorted...&quot;);
            }
            runs -= 1;
            if runs == 0 {
                break;
            }
        }
    }
    fn is_sorted(array: &amp;[u16]) -&gt; bool {
        for idx in 1..array.len() {
            if array[idx - 1] &gt; array[idx] {
                return false;
            }
        }
        true
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/quicksort/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lru-cache"><a class="header" href="#lru-cache">LRU cache</a></h1>
<p>Here we implement a cache that can hold key -&gt; value mappings in memory. The maximum 
capacity of cache is specified during instantiation and when storage reaches maximun 
capacity - least recently used entry is evicted.</p>
<p>The cache exposes the follwoing APIs:</p>
<ul>
<li><code>put</code> - inserts or updates</li>
<li><code>get</code> - get a value corresponding to a key</li>
<li><code>delete</code> - delete an entry from the cache</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The cache implementation depends on the doubly linked list implementation 
discussed in the previous section. Another noticeable thing is that - because our LRU 
cache implementation uses doulby linked list APIs, the implementation is quite concise, 
its about sixty odd lines when comments are ignored.</p>
</blockquote>
<h3 id="following-is-the-complete-implementation"><a class="header" href="#following-is-the-complete-implementation">Following is the complete implementation:</a></h3>
<pre><code class="language-rust  ignore">/// LRU cache implementation
use doubly_linked_list::{List, Node};
use std::cell::RefCell;
use std::collections::HashMap;
use std::hash::Hash;
use std::rc::{Rc, Weak};
//LRU Cache struct
pub struct LRUCache&lt;K: Eq + Hash, V: std::fmt::Debug + Default + Clone + PartialEq&gt; {
    keys: HashMap&lt;K, Weak&lt;RefCell&lt;Node&lt;V&gt;&gt;&gt;&gt;,
    entries: List&lt;V&gt;,
    capacity: usize,
}

impl&lt;K: Eq + Hash, V: std::fmt::Debug + Default + Clone + PartialEq&gt; LRUCache&lt;K, V&gt; {
    pub fn new(capacity: usize) -&gt; Self {
        Self {
            keys: HashMap::new(),
            entries: List::new(),
            capacity,
        }
    }
    //Insert (key, value)  to the cache
    //If key is already present - its value will be updated
    //If backing storage (doubly linked list) size goes beyond cache capacity,
    //least recently used entries will be evicted
    pub fn put(&amp;mut self, key: K, v: V) {
        match self.keys.get(&amp;key).and_then(|key| key.upgrade()) {
            //Insert if not present
            None =&gt; {
                self.entries.push_front(v);
                if let Some(front) = self.front() {
                    self.keys.insert(key, front);
                }
                self.purge_least_recently_used();
            }
            //Update if already exists
            Some(ref mut entry) =&gt; {
                entry.borrow_mut().replace(v);
                self.entries.to_front(entry);
            }
        }
    }
    //Called internally to get rid of least recently used entries
    fn purge_least_recently_used(&amp;mut self) {
        if self.entries.size() &gt; self.capacity {
            for _ in 0..(self.entries.size() - self.capacity) {
                let _ = self.entries.pop_back();
            }
        }
    }
    //Get a value corresponding to a key
    //Accessed entry, if found, moves to the front of backing storage
    pub fn get(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; {
        match self.keys.get(key).and_then(|key| key.upgrade()) {
            None =&gt; None,
            Some(ref entry) =&gt; {
                self.entries.to_front(entry);
                Some(entry.borrow().key().clone())
            }
        }
    }
    //Delete a cache entry
    pub fn delete(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; {
        match self.keys.get(key).and_then(|key| key.upgrade()) {
            None =&gt; None,
            Some(ref entry) =&gt; {
                self.keys.remove(key);
                self.entries.delete_target(entry)
            }
        }
    }
    //Get a weak reference to newly inserted value in the backing store
    //This value is stored in the lookup HashMap against its key
    fn front(&amp;self) -&gt; Option&lt;Weak&lt;RefCell&lt;Node&lt;V&gt;&gt;&gt;&gt; {
        self.entries.head().as_ref().map(Rc::downgrade)
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/lru_cache/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap"><a class="header" href="#heap">Heap</a></h1>
<p>Heap data structure.</p>
<p>First we implement a max heap, then a min heap and finally combine them together to provide an
unified heap struct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="max-heap"><a class="header" href="#max-heap">Max heap</a></h1>
<p>In max heap - parent element is always bigger than its children. When we insert an element to the
heap we insert it at right most postion of the underlying <code>Vec</code> data structure and comapre it with
its parent and move it up as long as it is bigger than its parent.</p>
<p>While removing - we take out the top element - replace it with the right most element. Next we,
look at its children to check if it is smaller than them. We swap parent with the bigger one of its
children and repeat the process til parent is no longer smaller than its children.</p>
<h3 id="following-is-the-entire-code-for-max-heap"><a class="header" href="#following-is-the-entire-code-for-max-heap">Following is the entire code for max heap:</a></h3>
<pre><code class="language-rust  ignore">/***
 * Implement a max heap data structure
 ***/

#[derive(Debug)]
pub struct MaxHeap&lt;T: Ord&gt; {
    elements: Vec&lt;T&gt;,
}

impl&lt;T: Ord&gt; MaxHeap&lt;T&gt; {
    pub fn new() -&gt; Self {
        MaxHeap {
            elements: Vec::new(),
        }
    }
    //Allocate memory upfront
    pub fn with_capacity(capacity: usize) -&gt; Self {
        MaxHeap {
            elements: Vec::with_capacity(capacity),
        }
    }
    
    pub fn size(&amp;self) -&gt; usize {
        self.elements.len()
    }

    fn get_parent_index(index: usize) -&gt; Option&lt;usize&gt; {
        match index {
            0 =&gt; None,
            _ =&gt; Some((index - 1) / 2),
        }
    }

    fn left_child_index(index: usize) -&gt; usize {
        2 * index + 1
    }

    fn right_child_index(index: usize) -&gt; usize {
        2 * index + 2
    }

    fn has_parent(index: usize) -&gt; bool {
        Self::get_parent_index(index).is_some()
    }

    fn has_left_child(&amp;self, index: usize) -&gt; bool {
        Self::left_child_index(index) &lt; self.elements.len()
    }

    fn has_right_child(&amp;self, index: usize) -&gt; bool {
        Self::right_child_index(index) &lt; self.elements.len()
    }

    fn parent(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        match Self::has_parent(index) {
            true =&gt; Some(&amp;self.elements[Self::get_parent_index(index).unwrap()]),
            false =&gt; None,
        }
    }

    fn left_child(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        match self.has_left_child(index) {
            true =&gt; Some(&amp;self.elements[Self::left_child_index(index)]),
            false =&gt; None,
        }
    }

    fn right_child(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        match self.has_right_child(index) {
            true =&gt; Some(&amp;self.elements[Self::right_child_index(index)]),
            false =&gt; None,
        }
    }

    pub fn insert(&amp;mut self, elem: T) {
        self.elements.push(elem);
        self.heapify_up();
    }

    //If the newly inserted element (at the last index) - is bigger than its parent,
    //swap parent and the element. Go to parent index position, continue the process
    //until element &gt; parent condition does not hold
    fn heapify_up(&amp;mut self) {
        let mut index = self.elements.len() - 1;
        while Self::has_parent(index) &amp;&amp; self.parent(index) &lt; self.elements.get(index) {
            let parent_index = Self::get_parent_index(index).unwrap();
            self.elements.swap(parent_index, index);
            index = parent_index;
        }
    }

    //Takeout the element at the top and replace it with the last
    //element and heapify down
    //Return the element taken out
    pub fn remove(&amp;mut self) -&gt; Option&lt;T&gt; {
        match self.is_empty() {
            true =&gt; None,
            false =&gt; {
                let t = self.elements.swap_remove(0);
                self.heapify_down();
                Some(t)
            }
        }
    }
    
    pub fn is_empty(&amp;self) -&gt; bool {
        self.elements.len() == 0
    }

    pub fn top(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        match self.is_empty() {
            true =&gt; None,
            false =&gt; self.elements.get(0),
        }
    }

    //Start at the top index element. If it is bigger than either of its children
    //we are done. Otherwise, bring top element down. Continue down.
    fn heapify_down(&amp;mut self) {
        let mut index = 0;
        while self.has_left_child(index) {
            let mut bigger_child_index = Self::left_child_index(index);
            if self.has_right_child(index) &amp;&amp; self.right_child(index) &gt; self.left_child(index) {
                bigger_child_index = Self::right_child_index(index);
            }
            if self.elements[index] &gt; self.elements[bigger_child_index] {
                break;
            } else {
                self.elements.swap(index, bigger_child_index);
            }
            index = bigger_child_index;
        }
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/max_heap/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="min-heap"><a class="header" href="#min-heap">Min heap</a></h1>
<p>In a min heap parent is always smaller than its children.</p>
<h3 id="following-is-the-code-for-min-heap"><a class="header" href="#following-is-the-code-for-min-heap">Following is the code for min heap:</a></h3>
<pre><code class="language-rust  ignore">/***
  * Implement a min heap data structure
 ***/

  #[derive(Debug)]
  pub struct MinHeap&lt;T: Ord&gt; {
      elements: Vec&lt;T&gt;,
  }

  impl&lt;T: Ord&gt; MinHeap&lt;T&gt; {
      pub fn new(capacity: usize) -&gt; Self {
          MinHeap {
              elements: Vec::with_capacity(capacity),
          }
      }

      fn get_parent_index(index: usize) -&gt; Option&lt;usize&gt; {
          match index {
              0 =&gt; None,
              _ =&gt; Some((index - 1) / 2),
          }
      }

      fn left_child_index(index: usize) -&gt; usize {
          2 * index + 1
      }

      fn right_child_index(index: usize) -&gt; usize {
          2 * index + 2
      }

      fn has_parent(index: usize) -&gt; bool {
          Self::get_parent_index(index).is_some()
      }

      fn has_left_child(&amp;self, index: usize) -&gt; bool {
          Self::left_child_index(index) &lt; self.elements.len()
      }

      fn has_right_child(&amp;self, index: usize) -&gt; bool {
          Self::right_child_index(index) &lt; self.elements.len()
      }

      fn parent(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
          match Self::has_parent(index) {
              true =&gt; Some(&amp;self.elements[Self::get_parent_index(index).unwrap()]),
              false =&gt; None,
          }
      }

      fn left_child(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
          match self.has_left_child(index) {
              true =&gt; Some(&amp;self.elements[Self::left_child_index(index)]),
              false =&gt; None,
          }
      }

      fn right_child(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
          match self.has_right_child(index) {
              true =&gt; Some(&amp;self.elements[Self::right_child_index(index)]),
              false =&gt; None,
          }
      }

      pub fn insert(&amp;mut self, elem: T) {
          self.elements.push(elem);
          self.heapify_up();
      }
      //Take newly inserted element up as long as it is its parent is bigger
      fn heapify_up(&amp;mut self) {
          let mut index = self.elements.len() - 1;
          while Self::has_parent(index) &amp;&amp; self.parent(index) &gt; self.elements.get(index) {
              let parent_index = Self::get_parent_index(index).unwrap();
              self.elements.swap(parent_index, index);
              index = parent_index;
          }
      }

      pub fn remove(&amp;mut self) -&gt; Option&lt;T&gt; {
          match self.elements.len() {
              0 =&gt; None,
              _ =&gt; {
                  let t = self.elements.swap_remove(0);
                  self.heapify_down();
                  Some(t)
              }
          }
      }
      //Bring parent down comparing it with its children as long as parent is bigger than its
      //children
      fn heapify_down(&amp;mut self) {
          let mut index = 0;
          while self.has_left_child(index) {
              let mut smaller_child_index = Self::left_child_index(index);
              if self.has_right_child(index) &amp;&amp; self.right_child(index) &lt; self.left_child(index) {
                  smaller_child_index = Self::right_child_index(index);
              }
              if self.elements[index] &lt; self.elements[smaller_child_index] {
                  break;
              } else {
                  self.elements.swap(index, smaller_child_index);
              }
              index = smaller_child_index;
          }
      }
  }
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/min_heap/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="max-min-heap"><a class="header" href="#max-min-heap">Max min heap</a></h1>
<p>Here we present a <code>Heap</code> struct that can be used either as <code>min heap</code> or <code>max heap</code> based on how we
instantiate it. <code>Heap::min</code> gives a min heap whereas <code>Heap::max</code> gives a max heap. Additionally, we
can use the <code>Heap::with_capacity</code> to pass in a boolean flag to get a max or min heap.</p>
<h3 id="below-is-the-code-for-the-heap-struct"><a class="header" href="#below-is-the-code-for-the-heap-struct">Below is the code for the heap struct:</a></h3>
<pre><code class="language-rust  ignore">/***
 * Implement a heap data structure that can be used as min or max heap
 ***/

pub struct Heap&lt;T: Ord&gt; {
    elements: Vec&lt;T&gt;,
    min: bool,
}

impl&lt;T: Ord&gt; Heap&lt;T&gt; {
    //Creates min heap
    pub fn min() -&gt; Self {
        Heap {
            elements: Vec::new(),
            min: true,
        }
    }
    //Creates a max heap
    pub fn max() -&gt; Self {
        Heap {
            elements: Vec::new(),
            min: false,
        }
    }

    //Allocate memory upfront
    //Creates a max or min heap based on the flag passed in
    pub fn with_capacity(capacity: usize, min: bool) -&gt; Self {
        Heap {
            elements: Vec::with_capacity(capacity),
            min,
        }
    }

    pub fn size(&amp;self) -&gt; usize {
        self.elements.len()
    }

    fn get_parent_index(index: usize) -&gt; Option&lt;usize&gt; {
        match index {
            0 =&gt; None,
            _ =&gt; Some((index - 1) / 2),
        }
    }

    fn left_child_index(index: usize) -&gt; usize {
        2 * index + 1
    }

    fn right_child_index(index: usize) -&gt; usize {
        2 * index + 2
    }

    fn has_parent(index: usize) -&gt; bool {
        Self::get_parent_index(index).is_some()
    }

    fn has_left_child(&amp;self, index: usize) -&gt; bool {
        Self::left_child_index(index) &lt; self.elements.len()
    }

    fn has_right_child(&amp;self, index: usize) -&gt; bool {
        Self::right_child_index(index) &lt; self.elements.len()
    }

    fn parent(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        match Self::has_parent(index) {
            true =&gt; Some(&amp;self.elements[Self::get_parent_index(index).unwrap()]),
            false =&gt; None,
        }
    }

    fn left_child(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        match self.has_left_child(index) {
            true =&gt; Some(&amp;self.elements[Self::left_child_index(index)]),
            false =&gt; None,
        }
    }

    fn right_child(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt; {
        match self.has_right_child(index) {
            true =&gt; Some(&amp;self.elements[Self::right_child_index(index)]),
            false =&gt; None,
        }
    }

    pub fn insert(&amp;mut self, elem: T) {
        self.elements.push(elem);
        self.heapify_up();
    }
    //If max heap - take the inserted element up as long as it is bigger than its parent
    //If min heap - take the inserted element up as long as it is smaller than its parent
    fn heapify_up(&amp;mut self) {
        let mut index = self.elements.len() - 1;
        while Self::has_parent(index)
            &amp;&amp; (!self.min &amp;&amp; self.parent(index) &lt; self.elements.get(index)
                || (self.min &amp;&amp; self.parent(index) &gt; self.elements.get(index)))
        {
            let parent_index = Self::get_parent_index(index).unwrap();
            self.elements.swap(parent_index, index);
            index = parent_index;
        }
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;T&gt; {
        match self.is_empty() {
            true =&gt; None,
            false =&gt; {
                let t = self.elements.swap_remove(0);
                self.heapify_down();
                Some(t)
            }
        }
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.elements.len() == 0
    }

    pub fn top(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        match self.is_empty() {
            true =&gt; None,
            false =&gt; self.elements.get(0),
        }
    }

    //If min heap, take the inserted element down as long as it is bigger than its children
    //If max heap, take the inserted element down as long as it is smaller than its children
    fn heapify_down(&amp;mut self) {
        let mut index = 0;
        while self.has_left_child(index) {
            let mut child_index = Self::left_child_index(index);
            if self.has_right_child(index)
                &amp;&amp; (!self.min &amp;&amp; self.right_child(index) &gt; self.left_child(index)
                    || (self.min &amp;&amp; self.right_child(index) &lt; self.left_child(index)))
            {
                child_index = Self::right_child_index(index);
            }
            if !self.min &amp;&amp; self.elements[index] &gt; self.elements[child_index] {
                break;
            } else if self.min &amp;&amp; self.elements[index] &lt; self.elements[child_index] {
                break;
            } else {
                self.elements.swap(index, child_index);
            }
            index = child_index;
        }
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/heap/src/lib.rs">Source</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trie"><a class="header" href="#trie">Trie</a></h1>
<p>Trie is a handy data structure. We can use it for storing words, search for entries and prefixes.</p>
<h3 id="below-is-trie-implementation"><a class="header" href="#below-is-trie-implementation">Below is <code>Trie</code> implementation:</a></h3>
<pre><code class="language-rust  ignore">/*** Implement Trie data structure that holds string ***/

use std::collections::HashMap;
struct Node {
    children: HashMap&lt;char, Node&gt;,
    is_word: bool,
}

impl Node {
    fn new() -&gt; Self {
        Node {
            children: HashMap::new(),
            is_word: false,
        }
    }
}
pub struct Trie {
    root: Node,
}

impl Trie {
    pub fn new() -&gt; Self {
        Trie { root: Node::new() }
    }
    //Insert a word into the Trie
    pub fn insert(&amp;mut self, word: &amp;str) {
        let mut current = &amp;mut self.root;
        let mut chars = word.chars();
        while let Some(c) = chars.next() {
            current = current.children.entry(c).or_insert(Node::new());
        }
        current.is_word = true;
    }
    //Seach for word in the Trie
    pub fn search(&amp;self, word: &amp;str) -&gt; bool {
        let mut current = &amp;self.root;
        let mut chars = word.chars();
        while let Some(c) = chars.next() {
            match current.children.get(&amp;c) {
                Some(ref node) =&gt; current = node,
                None =&gt; return false,
            }
        }
        current.is_word
    }
    //Is there a word that starts with the given prefix
    pub fn starts_with(&amp;self, prefix: &amp;str) -&gt; bool {
        let mut current = &amp;self.root;
        let mut chars = prefix.chars();
        while let Some(c) = chars.next() {
            match current.children.get(&amp;c) {
                Some(ref node) =&gt; current = node,
                None =&gt; return false,
            }
        }
        true
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/trie/src/lib.rs">Source</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-prefixsuffixes"><a class="header" href="#longest-prefixsuffixes">Longest prefix/suffixes</a></h1>
<p>Here we find longest prefixes and suffixes given an array strings. Inline comments are given for
longest suffix - we omit them for suffixes for brevity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-common-prefix"><a class="header" href="#longest-common-prefix">Longest common prefix</a></h1>
<h3 id="find-the-longest-common-prefix-for-given-array-of-strings"><a class="header" href="#find-the-longest-common-prefix-for-given-array-of-strings">Find the longest common prefix for given array of strings:</a></h3>
<pre><code class="language-rust  ignore">
/***
 * Find the longest prefix from an array of strings
 ***/

pub fn longest_common_prefix(arr: &amp;[&amp;str]) -&gt; String {
    if arr.len() == 0 {
        return String::new();
    }
    //Prefix would be as long as the min length of all the strings
    let mut result = String::with_capacity(
        arr.iter()
            .min_by(|p, n| p.len().cmp(&amp;n.len()))
            .unwrap()
            .len(),
    );
    //Get the characters of the first string in the in an iterator
    let mut first = arr[0].chars();
    //Map rests of the strings to iterator of chars and hold them in a vector
    let mut rests: Vec&lt;_&gt; = arr[1..].iter().map(|s| s.chars()).collect();
    //Iterate through the characters of the first string
    while let Some(ch) = first.next() {
        for i in 0..rests.len() {
            let current = &amp;mut rests[i];
            match current.next() {
                //Next string's next char matches with the first string char
                //jump to the next string
                Some(c) if c == ch =&gt; continue,
                //Does not match - return whatever we have go so far
                _ =&gt; return result,
            }
        }
        //All strings next char matched, lengthen result
        result.push(ch);
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn longest_common_prefix_test_1() {
        let arr = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;];
        assert_eq!(longest_common_prefix(&amp;arr), String::from(&quot;fl&quot;));

        let arr = [&quot;flower1&quot;, &quot;flower2&quot;, &quot;flower3&quot;];
        assert_eq!(longest_common_prefix(&amp;arr), String::from(&quot;flower&quot;));
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/longest_common_prefix/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-common-suffix"><a class="header" href="#longest-common-suffix">Longest common suffix</a></h1>
<h3 id="find-the-longest-common-suffix-given-an-array-of-strings"><a class="header" href="#find-the-longest-common-suffix-given-an-array-of-strings">Find the longest common suffix given an array of strings:</a></h3>
<pre><code class="language-rust  ignore">/***
 * Given an array of strings, find the logests common suffix for them
 ***/

pub fn longest_common_suffix(arr: &amp;[&amp;str]) -&gt; String {
    if arr.len() == 0 {
        return String::new();
    }
    //Suffix would be as long as the min length of all the strings
    let mut result = String::with_capacity(
        arr.iter()
            .min_by(|p, n| p.len().cmp(&amp;n.len()))
            .unwrap()
            .len(),
    );
    let mut first = arr[0].chars();
    let mut rests: Vec&lt;_&gt; = arr[1..].iter().map(|s| s.chars()).collect();
    while let Some(ch) = first.next_back() {
        for i in 0..rests.len() {
            let current = &amp;mut rests[i];
            match current.next_back() {
                Some(c) if c == ch =&gt; continue,
                _ =&gt; return result,
            }
        }
        //We are comming from the back - hence insert the next before the already existing char
        result.insert(0, ch);
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn longest_common_suffix_test() {
        let arr = [&quot;privacy&quot;];
        let result = longest_common_suffix(&amp;arr);
        assert_eq!(result, String::from(&quot;privacy&quot;));

        let arr = [&quot;privacy&quot;, &quot;fallacy&quot;, &quot;delicacy&quot;];
        let result = longest_common_suffix(&amp;arr);
        assert_eq!(result, String::from(&quot;acy&quot;));

        let arr = [&quot;freedom&quot;, &quot;kingdom&quot;, &quot;boredom&quot;];
        let result = longest_common_suffix(&amp;arr);
        assert_eq!(result, String::from(&quot;dom&quot;));
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/longest_common_suffix/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-permutation"><a class="header" href="#string-permutation">String permutation</a></h1>
<h3 id="given-string-s-find-all-the-permutations-of-its-characters"><a class="header" href="#given-string-s-find-all-the-permutations-of-its-characters">Given string s, find all the permutations of its characters:</a></h3>
<pre><code class="language-rust ignore">/***
 * Given a string, find all the unique permutations of its characters
 ***/
pub fn permutate(s: &amp;str) -&gt; Vec&lt;String&gt; {
    let mut result = Vec::new();
    if s.len() == 0 {
        return result;
    }
    if s.len() == 1 {
        result.push(s.to_string());
        return result;
    }
    let chars: Vec&lt;_&gt; = s.chars().collect();
    for i in 0..chars.len() {
        let ch = chars[i];
        let mut segment = String::from(&amp;s[0..i]);
        segment += &amp;s[i + 1..];
        let intermediates = permutate(&amp;segment);
        for mut s in intermediates {
            s.push(ch);
            result.push(s);
        }
    }
    result
}
#[cfg(test)]
mod tests {
    use super::permutate;
    #[test]
    fn permutate_test() {
        let result = permutate(&quot;abc&quot;);
        assert_eq!(
            result,
            vec![
                String::from(&quot;cba&quot;),
                String::from(&quot;bca&quot;),
                String::from(&quot;cab&quot;),
                String::from(&quot;acb&quot;),
                String::from(&quot;bac&quot;),
                String::from(&quot;abc&quot;)
            ]
        );
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/tree/master/permutations/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merge-k-sorted-arrays"><a class="header" href="#merge-k-sorted-arrays">Merge k sorted arrays</a></h1>
<p>Here we present a simple routine to merge k sorted arrays which might not be of same
lengths. We make use our <code>Heap</code> datastructure that we developed earlier. We also, make 
use of tuple struct to maintain the state of each array while we are iterating over them.</p>
<h3 id="following-is-the-implementation-2"><a class="header" href="#following-is-the-implementation-2">Following is the implementation:</a></h3>
<pre><code class="language-rust  ignore">//Merge k sorted arrays. Arrays are not of equal lengths
use heap::Heap;

pub fn merge(arrays: &amp;[&amp;[i32]]) -&gt; Vec&lt;i32&gt; {
    let mut heap = Heap::min();
    let mut size = 0;
    for i in 0..arrays.len() {
        size += arrays[i].len();
        if arrays[i].len() &gt; 0 {
            let elem = Elem::new(arrays[i][0], i, 0);
            heap.insert(elem);
        }
    }
    let mut result: Vec&lt;i32&gt; = Vec::with_capacity(size);
    while !heap.is_empty() {
        let elem = heap.remove().unwrap();
        let value = elem.0;
        let array_idx = elem.1;
        let value_idx = elem.2;
        if value_idx + 1 &lt; arrays[array_idx].len() {
            heap.insert(Elem::new(
                arrays[array_idx][value_idx + 1],
                array_idx,
                value_idx + 1,
            ));
        }
        result.push(value);
    }
    result
}
#[derive(Eq, Ord, PartialEq, PartialOrd)]
struct Elem&lt;T: Ord&gt;(T, usize, usize);

impl&lt;T: Ord&gt; Elem&lt;T&gt; {
    fn new(value: T, array_idx: usize, value_idx: usize) -&gt; Self {
        Elem(value, array_idx, value_idx)
    }
}

#[cfg(test)]
mod tests {
    use super::merge;
    #[test]
    fn merge_test() {
        assert_eq!(
            merge(&amp;[&amp;[1, 3, 5, 6, 7], &amp;[0, 2, 4], &amp;[2, 4, 6, 8, 9, 10]]),
            vec![0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 10]
        );
    }
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/merge_ksorted_arrays/src/lib.rs">Source</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substring-with-concatenation-of-all-words"><a class="header" href="#substring-with-concatenation-of-all-words">Substring with Concatenation of All Words</a></h1>
<p>Given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.</p>
<p>The answer can be in any order.</p>
<p>Example 1:</p>
<p>Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoo&quot; and &quot;foobar&quot; respectively
The output order does not matter, returning [9,0] is fine too.</p>
<p>Example 2:</p>
<p>Input: s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</p>
<p>Output: [12]</p>
<p>Ingnore the duplicate search words above.</p>
<p>Example 3:</p>
<p>Input: s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</p>
<p>Output: [6,9,12]</p>
<h3 id="solution-explanation-we-use-a-double-ended-queue-for-this-solution-we-keep-iterating-through-the-given-input-string-for-chuncks"><a class="header" href="#solution-explanation-we-use-a-double-ended-queue-for-this-solution-we-keep-iterating-through-the-given-input-string-for-chuncks">Solution explanation: We use a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">double ended queue</a> for this solution. We keep iterating through the given input string for chuncks</a></h3>
<p>of words equal in length to the search key words' and keep pushing them into the queue. When we the 
queue size becomes equal to the search key words' array size, we add the index of the first chunck 
to the result vector and delete all entries but the last - because that could be the beginning of 
another substring. If we encounter duplicate immediately after a previous chunck - we clear queue 
and add just only the current chunck. We also check for previous duplicates - and remove them if any. </p>
<h3 id="following-is-the-implementation-3"><a class="header" href="#following-is-the-implementation-3">Following is the implementation:</a></h3>
<pre><code class="language-rust  ignore">/// Substring with Concatenation of All Words

use std::collections::HashSet;
use std::collections::VecDeque;

pub fn find_substring(s: String, search_words: Vec&lt;String&gt;) -&gt; Vec&lt;usize&gt; {
    if s.is_empty() || search_words.is_empty() {
        return vec![];
    }
    let result = substring_indices(s, search_words);
    result
}

fn substring_indices(s: String, words: Vec&lt;String&gt;) -&gt; Vec&lt;usize&gt; {
    let mut result = Vec::new();
    if s.is_empty() || words.is_empty() {
        return result;
    }
    let mut stack: VecDeque&lt;(&amp;str, usize)&gt; = VecDeque::with_capacity(words.len());
    let split_size = words[0].len();
    //Get rid of duplicate search words
    let words = HashSet::&lt;String&gt;::from_iter(words);
    let mut index = 0;
    while index &lt;= s.len() - split_size {
        let chunck = &amp;s[index..index + split_size];
        if words.contains(&amp;chunck.to_string()) {
            if let Some(back) = stack.back() {
                if &amp;back.0 == &amp;chunck {
                    stack.clear();
                    stack.push_back((chunck, index));
                } else {
                    let repeat = stack
                        .iter()
                        .enumerate()
                        .find(|repeat| repeat.1 .0 == chunck);
                    if let Some(repeat) = repeat {
                        for _ in 0..=repeat.0 {
                            stack.pop_front();
                        }
                    }
                    stack.push_back((chunck, index));
                }
            } else {
                stack.push_back((chunck, index));
            }
        } else {
            stack.clear();
        }
        if stack.len() == words.len() {
            let first = stack.pop_front();
            if words.len() &gt;= 2 {
                for _ in 0..words.len() - 2 {
                    stack.pop_front();
                }
            }
            if let Some(first) = first {
                result.push(first.1);
            }
        }
        index += split_size;
    }
    result
}
</code></pre>
<p><a href="https://github.com/ratulb/programming_problems_in_rust/blob/master/substring_concatenation/src/lib.rs">Source</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
