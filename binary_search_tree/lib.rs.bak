use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::{Rc, Weak};
use std::sync::Arc;
use std::sync::Mutex;
use thread_local::ThreadLocal;

#[derive(Debug)]
pub struct BSTree<T: Ord + Clone + Send>(Option<Rc<RefCell<Node<T>>>>);

#[derive(Debug)]
struct Node<'a, T: Ord + Clone + Send> {
    key: T,
    left: Option<Rc<RefCell<Node<T>>>>,
    right: Option<Rc<RefCell<Node<T>>>>,
    parent: Option<Rc<RefCell<Weak<Node<T>>>>>,
    tls: Option<ThreadLocal<HashMap<&'a T, Arc<Mutex<Node<T>>>>>>,
}

unsafe impl<T: Ord + Clone + Send> Send for Node<T> {}
unsafe impl<T: Ord + Clone + Send> Sync for Node<T> {}

impl<T: Ord + Clone + Send> Node<T> {
    pub fn new(value: T) -> Rc<RefCell<Self>> {
        let result = Rc::new(RefCell::new(Self {
            key: value,
            left: None,
            right: None,
            parent: None,
            tls: Some(ThreadLocal::new()),
        }));
        result
        //let rc = Rc::new(result);
        // return Rc::clone(&rc);
    }

    fn is_greater_than_self(&self, value: &T) -> bool {
        value > &self.key
    }
    //How can we avoid clone?
    fn evict_left(&mut self) -> Option<T> {
        self.left.take().map(|cell| cell.borrow().key.clone())
    }

    fn swap_right_to_left(&mut self) {
        self.left = self.right.take();
    }

    fn is_left_filled(&self) -> bool {
        self.left.is_some()
    }
    fn is_right_filled(&self) -> bool {
        self.right.is_some()
    }

    pub fn insert(&mut self, value: T) {
        if value > self.key {
            match self.left {
                Some(ref mut left) => Self::insert(&mut left.borrow_mut(), value),
                None => self = Rc::new(self),
            }
        }
    }

    /***pub fn insert(&mut self, value: T) {
        if self.key > value {
            match self.left {
                Some(ref mut left) => {
                    Self::insert(&mut left.borrow_mut(), value);
                }
                None => {
                    let mut new_node = Rc::new(RefCell::new(Node::new(value)));
                    //let parent_ref = Rc::new(RefCell::new(Rc::clone(self)));
                }
            }
        } else if self.key < value {
        }
    }***/
}

/***impl<T: Ord> BSTree<T> {
    pub fn empty() -> Self {
        BSTree(None)
    }

    pub fn new(value: T) -> Self {
        BSTree(Some(Rc::new(RefCell::new(Node::new(value)))))
    }

    pub fn insert(&mut self, value: T) {
        match self.0 {
            None => self.0 = Some(Rc::new(RefCell::new(Node::new(value)))),
            Some(ref mut node) => {
                let mut node = node.borrow_mut();
                if value < node.key {
                    match node.left {
                        Some(ref mut l) => Self::insert(&mut l.borrow_mut(), value),
                        None => {
                            let mut new_node = Rc::new(RefCell::new(Node::new(value)));
                            /***let parent_ref  = match self {
                               BSTree(Some(_)) => todo!(),//Rc::downgrade(&Rc::clone(this)),
                               BSTree(None) => todo!(),
                            };***/
                        }
                    }
                }
            }
        }
    }
}***/

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
